
\begin{DoxyRefList}
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000011}%
\Hypertarget{bug__bug000011}%
Member \mbox{\hyperlink{group__apr__time_ga82e8a0064bc8dd25ef73f39ea428a585}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (void) apr\+\_\+sleep(apr\+\_\+interval\+\_\+time\+\_\+t t)]write\+\_\+fd duplicates the proc-\/$>$out stream, it\textquotesingle{}s really redundant and should be replaced in the A\+PR 1.\+0 A\+PI with a bitflag of which proc-\/$>$in/out/err handles should be health checked. 

no platform currently tests the pipes health.  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000011}%
\Hypertarget{bug__bug000011}%
Member \mbox{\hyperlink{group__apr__time_ga82e8a0064bc8dd25ef73f39ea428a585}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (void) apr\+\_\+sleep(apr\+\_\+interval\+\_\+time\+\_\+t t)]write\+\_\+fd duplicates the proc-\/$>$out stream, it\textquotesingle{}s really redundant and should be replaced in the A\+PR 1.\+0 A\+PI with a bitflag of which proc-\/$>$in/out/err handles should be health checked. 

no platform currently tests the pipes health.  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000011}%
\Hypertarget{bug__bug000011}%
Member \mbox{\hyperlink{group__apr__time_ga82e8a0064bc8dd25ef73f39ea428a585}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (void) apr\+\_\+sleep(apr\+\_\+interval\+\_\+time\+\_\+t t)]write\+\_\+fd duplicates the proc-\/$>$out stream, it\textquotesingle{}s really redundant and should be replaced in the A\+PR 1.\+0 A\+PI with a bitflag of which proc-\/$>$in/out/err handles should be health checked. 

no platform currently tests the pipes health.  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000002}%
\Hypertarget{bug__bug000002}%
Member \mbox{\hyperlink{group__apr__time_ga57bfe39a9516843a151a65cd02f84616}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+RE}} (apr\+\_\+status\+\_\+t) apr\+\_\+time\+\_\+ansi\+\_\+put(apr\+\_\+time\+\_\+t $\ast$result]Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-\/blocking stream will fluxor the client app. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

With versions 1.\+4.\+2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. 

$\ast$end breaks type safety; where $\ast$buf is const, $\ast$end needs to be declared as const in A\+PR 2.\+0 

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Note that calling this function with two N\+U\+LL files on some platforms creates an A\+P\+R\+\_\+\+F\+U\+L\+L\+\_\+\+B\+L\+O\+CK pipe, but this behavior is neither portable nor is it supported.

Passing proc as a $\ast$proc rather than $\ast$$\ast$proc was an odd choice for some platforms... this should be revisited in 1.\+0  
\item[\label{bug__bug000001}%
\Hypertarget{bug__bug000001}%
Member \mbox{\hyperlink{group__apr__filepath_gabb57ce7b23caf512d7f64b92a662ab3d}{A\+P\+R\+\_\+\+F\+I\+L\+E\+P\+A\+T\+H\+\_\+\+N\+O\+T\+A\+B\+O\+V\+E\+R\+O\+OT}} ]in A\+PR 0.\+9 and 1.\+x, this flag\textquotesingle{}s behavior is undefined if the rootpath is N\+U\+LL or empty. In A\+PR 2.\+0 this should be changed to imply N\+O\+T\+A\+B\+S\+O\+L\+U\+TE if the rootpath is N\+U\+LL or empty. 
\end{DoxyRefList}