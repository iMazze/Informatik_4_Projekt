\hypertarget{group___pool_cleanup}{}\section{Pool Cleanup Functions}
\label{group___pool_cleanup}\index{Pool Cleanup Functions@{Pool Cleanup Functions}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group___pool_cleanup_ga18235426bac93f23261221f9b3733bfd}{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+TD}} (\mbox{\hyperlink{group__apr__errno_gaf76ee4543247e9fb3f3546203e590a6c}{apr\+\_\+status\+\_\+t}}) apr\+\_\+pool\+\_\+cleanup\+\_\+null(void $\ast$data)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group___pool_cleanup_ga735984d41155bc1032e09bece8f8d66d}\label{group___pool_cleanup_ga735984d41155bc1032e09bece8f8d66d}} 
const void $\ast$ {\bfseries data}
\item 
\mbox{\Hypertarget{group___pool_cleanup_ga329cbf0c5d8e0c61c40f78cdf67d4471}\label{group___pool_cleanup_ga329cbf0c5d8e0c61c40f78cdf67d4471}} 
const void \mbox{\hyperlink{group__apr__errno_gaf76ee4543247e9fb3f3546203e590a6c}{apr\+\_\+status\+\_\+t}}($\ast$ {\bfseries plain\+\_\+cleanup} )(void $\ast$)
\item 
\mbox{\Hypertarget{group___pool_cleanup_ga5b82f9699d8aa32f293f26d54f813706}\label{group___pool_cleanup_ga5b82f9699d8aa32f293f26d54f813706}} 
const void \mbox{\hyperlink{group__apr__errno_gaf76ee4543247e9fb3f3546203e590a6c}{apr\+\_\+status\+\_\+t}}($\ast$) \mbox{\hyperlink{group__apr__errno_gaf76ee4543247e9fb3f3546203e590a6c}{apr\+\_\+status\+\_\+t}}($\ast$ {\bfseries child\+\_\+cleanup} )(void $\ast$))
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Cleanups are performed in the reverse order they were registered. That is\+: Last In, First Out. A cleanup function can safely allocate memory from the pool that is being cleaned up. It can also safely register additional cleanups which will be run L\+I\+FO, directly after the current cleanup terminates. Cleanups have to take caution in calling functions that create subpools. Subpools, created during cleanup will N\+OT automatically be cleaned up. In other words, cleanups are to clean up after themselves. 

\subsection{Function Documentation}
\mbox{\Hypertarget{group___pool_cleanup_ga18235426bac93f23261221f9b3733bfd}\label{group___pool_cleanup_ga18235426bac93f23261221f9b3733bfd}} 
\index{Pool Cleanup Functions@{Pool Cleanup Functions}!A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+TD@{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+TD}}
\index{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+TD@{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+TD}!Pool Cleanup Functions@{Pool Cleanup Functions}}
\subsubsection{\texorpdfstring{A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+T\+D()}{APR\_DECLARE\_NONSTD()}}
{\footnotesize\ttfamily A\+P\+R\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+N\+O\+N\+S\+TD (\begin{DoxyParamCaption}\item[{int}]{ }\end{DoxyParamCaption})}

An empty cleanup function.

Passed to apr\+\_\+pool\+\_\+cleanup\+\_\+register() when no cleanup is required.


\begin{DoxyParams}{Parameters}
{\em data} & The data to cleanup, will not be used by this function.\\
\hline
\end{DoxyParams}
Write a string to a file using a printf format. 
\begin{DoxyParams}{Parameters}
{\em fptr} & The file to write to. \\
\hline
{\em format} & The format string \\
\hline
{\em ...} & The values to substitute in the format string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written
\end{DoxyReturn}
snprintf routine based on apr\+\_\+vformatter. This means it understands the same extensions. 
\begin{DoxyParams}{Parameters}
{\em buf} & The buffer to write to \\
\hline
{\em len} & The size of the buffer \\
\hline
{\em format} & The format string \\
\hline
{\em ...} & The arguments to use to fill out the format string.\\
\hline
\end{DoxyParams}
Iterate over a table running the provided function once for every element in the table. The varargs array must be a list of zero or more (char $\ast$) keys followed by a N\+U\+LL pointer. If zero keys are given, the
\begin{DoxyParams}{Parameters}
{\em comp} & function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.\\
\hline
\end{DoxyParams}
If an invocation of the
\begin{DoxyParams}{Parameters}
{\em comp} & function returns zero, iteration will continue using the next specified key, if any.\\
\hline
{\em comp} & The function to run \\
\hline
{\em rec} & The data to pass as the first argument to the function \\
\hline
{\em t} & The table to iterate over \\
\hline
{\em ...} & A varargs array of zero or more (char $\ast$) keys followed by N\+U\+LL \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
F\+A\+L\+SE if one of the comp() iterations returned zero; T\+R\+UE if all iterations returned non-\/zero 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__apr__tables_ga633325e16f9e1f81adce476fb71cbd88}{apr\+\_\+table\+\_\+do\+\_\+callback\+\_\+fn\+\_\+t}} 
\end{DoxySeeAlso}
