<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Complex Calculator: Internal Memory Allocation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Complex Calculator
   </div>
   <div id="projectbrief">DHBW Friedrichshafen: Informatik 4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Internal Memory Allocation</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__memnode__t.html">apr_memnode_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf382851817012929f4e2458b43f4482c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gaf382851817012929f4e2458b43f4482c">APR_MEMNODE_T_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__apr__general.html#gab484e98426221f3212fcb67af0467381">APR_ALIGN_DEFAULT</a>(sizeof(<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>))</td></tr>
<tr class="separator:gaf382851817012929f4e2458b43f4482c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f32b19d8dad59bc6364a7a6b8ebec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga54f32b19d8dad59bc6364a7a6b8ebec9">APR_ALLOCATOR_MAX_FREE_UNLIMITED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga54f32b19d8dad59bc6364a7a6b8ebec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1ceabfd30fcfc455e47d052d2a24244b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a></td></tr>
<tr class="separator:ga1ceabfd30fcfc455e47d052d2a24244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6437036dfcdffbf87ad4677c818211"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga3b6437036dfcdffbf87ad4677c818211">apr_memnode_t</a></td></tr>
<tr class="separator:ga3b6437036dfcdffbf87ad4677c818211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaac44cde286d1fa89f3063a38e1f56093"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gaac44cde286d1fa89f3063a38e1f56093">APR_DECLARE</a> (<a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>) apr_allocator_create(<a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> **allocator)</td></tr>
<tr class="separator:gaac44cde286d1fa89f3063a38e1f56093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb34a3c199088334b7cf35f075272878"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gacb34a3c199088334b7cf35f075272878">APR_DECLARE</a> (void) apr_allocator_destroy(<a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator)</td></tr>
<tr class="separator:gacb34a3c199088334b7cf35f075272878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a358d9857909db42118ab336d2ed241"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga1a358d9857909db42118ab336d2ed241">APR_DECLARE</a> (<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> *) apr_allocator_alloc(<a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator</td></tr>
<tr class="separator:ga1a358d9857909db42118ab336d2ed241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabccd1c0312bb5004cdca788c3a3422f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gabccd1c0312bb5004cdca788c3a3422f9">APR_DECLARE</a> (<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *) apr_allocator_owner_get(<a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> *allocator)</td></tr>
<tr class="separator:gabccd1c0312bb5004cdca788c3a3422f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5f598d678d0ca77c25732a145c68d3c7"><td class="memItemLeft" align="right" valign="top"><a id="ga5f598d678d0ca77c25732a145c68d3c7"></a>
apr_size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="separator:ga5f598d678d0ca77c25732a145c68d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166d54a5e4115d8b15b643e511b795be"><td class="memItemLeft" align="right" valign="top"><a id="ga166d54a5e4115d8b15b643e511b795be"></a>
<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>memnode</b></td></tr>
<tr class="separator:ga166d54a5e4115d8b15b643e511b795be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4eb4084d76e9e1f2f2fa495c57ceb2"><td class="memItemLeft" align="right" valign="top"><a id="ga4d4eb4084d76e9e1f2f2fa495c57ceb2"></a>
<a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pool</b></td></tr>
<tr class="separator:ga4d4eb4084d76e9e1f2f2fa495c57ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga54f32b19d8dad59bc6364a7a6b8ebec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f32b19d8dad59bc6364a7a6b8ebec9">&#9670;&nbsp;</a></span>APR_ALLOCATOR_MAX_FREE_UNLIMITED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ALLOCATOR_MAX_FREE_UNLIMITED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symbolic constants </p>

</div>
</div>
<a id="gaf382851817012929f4e2458b43f4482c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf382851817012929f4e2458b43f4482c">&#9670;&nbsp;</a></span>APR_MEMNODE_T_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_MEMNODE_T_SIZE&#160;&#160;&#160;<a class="el" href="group__apr__general.html#gab484e98426221f3212fcb67af0467381">APR_ALIGN_DEFAULT</a>(sizeof(<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The base size of a memory node - aligned. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga1ceabfd30fcfc455e47d052d2a24244b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ceabfd30fcfc455e47d052d2a24244b">&#9670;&nbsp;</a></span>apr_allocator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a> <a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the allocator structure </p>

</div>
</div>
<a id="ga3b6437036dfcdffbf87ad4677c818211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b6437036dfcdffbf87ad4677c818211">&#9670;&nbsp;</a></span>apr_memnode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> <a class="el" href="structapr__memnode__t.html">apr_memnode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the structure which holds information about the allocation </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaac44cde286d1fa89f3063a38e1f56093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac44cde286d1fa89f3063a38e1f56093">&#9670;&nbsp;</a></span>APR_DECLARE() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator we have just created.</td></tr>
  </table>
  </dd>
</dl>
<p>atomically decrement an apr_uint32_t by 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the atomic value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the value becomes zero on decrement, otherwise non-zero</dd></dl>
<p>Set the value of an environment variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Delete a variable from the environment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Open the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_dir</td><td>The opened directory descriptor. </td></tr>
    <tr><td class="paramname">dirname</td><td>The full path to the directory (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>close the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Read the next entry from the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>the file info structure and filled in by apr_dir_read </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">thedir</td><td>the directory descriptor returned from apr_dir_open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>No ordering is guaranteed for the entries read.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>APR_INCOMPLETE</code> is returned all the fields in <em>finfo</em> may not be filled in, and you need to check the <code>finfo-&gt;valid</code> bitmask to verify that what you're looking for is there. When no more entries are available, APR_ENOENT is returned.</dd></dl>
<p>Rewind the directory to the first entry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to rewind.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the rootpath from the given filepath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootpath</td><td>the root file path returned with APR_SUCCESS or APR_EINCOMPLETE </td></tr>
    <tr><td class="paramname">filepath</td><td>the pathname to parse for its root component </td></tr>
    <tr><td class="paramname">flags</td><td>the desired rules to apply, from <pre>
     APR_FILEPATH_NATIVE    Use native path seperators (e.g. '\' on Win32)
     APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>on return, filepath points to the first non-root character in the given filepath. In the simplest example, given a filepath of "/foo", returns the rootpath of "/" and filepath points at "foo". This is far more complex on other platforms, which will canonicalize the root form to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also test for the validity of that root (e.g., that a drive d:/ or network share //machine/foovol/). The function returns APR_ERELATIVE if filepath isn't rooted (an error), APR_EINCOMPLETE if the root path is ambigious (but potentially legitimate, e.g. "/" on Windows is incomplete because it doesn't specify the drive letter), or APR_EBADPATH if the root is simply invalid. APR_SUCCESS is returned if filepath is an absolute path.</dd></dl>
<p>Merge additional file path onto the previously processed rootpath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpath</td><td>the merged paths returned </td></tr>
    <tr><td class="paramname">rootpath</td><td>the root file path (NULL uses the current working path) </td></tr>
    <tr><td class="paramname">addpath</td><td>the path to add to the root path </td></tr>
    <tr><td class="paramname">flags</td><td>the desired APR_FILEPATH_ rules to apply when merging </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the flag APR_FILEPATH_TRUENAME is given, and the addpath contains wildcard characters ('*', '?') on platforms that don't support such characters within filenames, the paths will be merged, but the result code will be APR_EPATHWILD, and all further segments will not reflect the true filenames including the wildcard and following segments.</dd></dl>
<p>Split a search path into separate components </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathelts</td><td>the returned components of the search path </td></tr>
    <tr><td class="paramname">liststr</td><td>the search path (e.g., <code>getenv("PATH")</code>) </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the array and path components from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>empty path componenta do not become part of <em>pathelts</em>. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Merge a list of search path components into a single search path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">liststr</td><td>the returned search path; may be NULL if <em>pathelts</em> is empty </td></tr>
    <tr><td class="paramname">pathelts</td><td>the components of the search path </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the search path from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>emtpy strings in the source array are ignored. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Return the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path string returned </td></tr>
    <tr><td class="paramname">flags</td><td>optional flag APR_FILEPATH_NATIVE to retrieve the default file path in os-native format. </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the default path string from</td></tr>
  </table>
  </dd>
</dl>
<p>Set the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path returned </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the encoding used internally by the FilePath functions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>points to a variable which receives the encoding style flag </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <code>apr_os_locale_encoding</code> and/or <code>apr_os_default_encoding</code> to get the name of the path encoding if it's not UTF-8.</dd></dl>
<p>Close the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the file is open, it won't be removed until all instances are closed.</dd></dl>
<p>Rename the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If a file exists at the new location, then it will be overwritten. Moving files or directories across devices may not be possible.</dd></dl>
<p>Create a hard link to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Both files must reside on the same device.</dd></dl>
<p>Copy the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the new file if it is created. In place of the usual or'd combination of file permissions, the value APR_FILE_SOURCE_PERMS may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the new file already exists, its contents will be overwritten.</dd></dl>
<p>Append the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the source file (use / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the destination file (use / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the destination file if it is created. In place of the usual or'd combination of file permissions, the value APR_FILE_SOURCE_PERMS may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required.</dd></dl>
<p>Are we at the end of the file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fptr</td><td>The apr file we are testing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns APR_EOF if we are at the end of file, APR_SUCCESS otherwise.</dd></dl>
<p>Open standard error as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The only reason that the apr_file_open_std* functions exist is that you may not always have a stderr/out/in on Windows. This is generally a problem with newer versions of Windows and services.</dd>
<dd>
The other problem is that the C library functions generally work differently on Windows and Unix. So, by using apr_file_open_std* functions, you can get a handle to an APR struct that works with the APR functions which are supposed to work identically on all platforms.</dd></dl>
<p>open standard output as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard input as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard error as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the APR_EXCL, APR_BUFFERED, APR_XTHREAD, APR_SHARELOCK, APR_SENDFILE_ENABLED and APR_LARGEFILE flags should be used. The APR_WRITE flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard output as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the APR_EXCL, APR_BUFFERED, APR_XTHREAD, APR_SHARELOCK, APR_SENDFILE_ENABLED and APR_LARGEFILE flags should be used. The APR_WRITE flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard input as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the APR_EXCL, APR_BUFFERED, APR_XTHREAD, APR_SHARELOCK, APR_SENDFILE_ENABLED and APR_LARGEFILE flags should be used. The APR_READ flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>Read data from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to read; on exit, the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, all of the available data is read. The third argument is modified to reflect the number of bytes read. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is not possible for both bytes to be read and an APR_EOF or other error to be returned. APR_EINTR is never returned.</dd></dl>
<p>Write data to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to write; on exit, the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, it will write as many as it can. The third argument is modified to reflect the * number of bytes written.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. APR_EINTR is never returned.</dd></dl>
<p>Write data from iovec array to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than APR_MAX_IOVEC_SIZE. If it isn't, the function will fail with APR_EINVAL. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible for both bytes to be written and an error to be returned. APR_EINTR is never returned.</dd>
<dd>
apr_file_writev is available even if the underlying operating system doesn't provide writev().</dd></dl>
<p>Read data from the specified file, ensuring that the buffer is filled before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>If non-NULL, this will contain the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, then the process/thread will block until it is available or EOF is reached. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is possible for both bytes to be read and an error to be returned. And if *bytes_read is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
APR_EINTR is never returned.</dd></dl>
<p>Write data to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">bytes_written</td><td>If non-NULL, set to the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, the process/thread will block until they can be written. Exceptional error such as "out of space" or "pipe closed" will terminate with an error.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. And if *bytes_written is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
APR_EINTR is never returned.</dd></dl>
<p>Write data from iovec array to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than APR_MAX_IOVEC_SIZE. If it isn't, the function will fail with APR_EINVAL. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_writev_full is available even if the underlying operating system doesn't provide writev().</dd></dl>
<p>Write a character into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a character from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to read into </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from</td></tr>
  </table>
  </dd>
</dl>
<p>Put a character back onto a specified stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a line from the specified file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The buffer to store the string in. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer will be NUL-terminated if any characters are stored. The newline at the end of the line will not be stripped.</dd></dl>
<p>Write the string into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Flush the file's buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to flush</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data and metadata to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Duplicate the specified file descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The structure to duplicate into. </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>*new_file must point to a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>, or point to NULL.</dd></dl>
<p>Duplicate the specified file descriptor and close the original </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The old file that is to be closed and reused </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>new_file MUST point at a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>. It cannot be NULL.</dd></dl>
<p>Move the specified file descriptor to a new pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>Pointer in which to return the new <a class="el" href="structapr__file__t.html">apr_file_t</a> </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to move </td></tr>
    <tr><td class="paramname">p</td><td>The pool to which the descriptor is to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike apr_file_dup2(), this function doesn't do an OS dup() operation on the underlying descriptor; it just moves the descriptor's <a class="el" href="structapr__file__t.html">apr_file_t</a> wrapper to a new pool. </dd>
<dd>
The new pool need not be an ancestor of old_file's pool. </dd>
<dd>
After calling this function, old_file may not be used</dd></dl>
<p>Give the specified apr file handle a new buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file handle that is to be modified </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible to add a buffer to previously unbuffered file handles, the APR_BUFFERED flag will be added to the file handle's flags. Likewise, with buffer=NULL and bufsize=0 arguments it is possible to make a previously buffered file handle unbuffered.</dd></dl>
<p>Move the read/write file offset to a specified byte within a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor </td></tr>
    <tr><td class="paramname">where</td><td>How to move the pointer, one of: <pre>
           APR_SET  --  set the offset to offset
           APR_CUR  --  add the offset to the current position 
           APR_END  --  add the offset to the current file size 
</pre> </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to move the pointer to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The third argument is modified to be the offset the pointer was actually moved to.</dd></dl>
<p>Create an anonymous pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_file_pipe_create_ex</dd></dl>
<p>Create an anonymous pipe which portably supports async timeout options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">blocking</td><td>one of these values defined in <a class="el" href="apr__thread__proc_8h.html" title="APR Thread and Process Library. ">apr_thread_proc.h</a>; </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. <pre>
      APR_FULL_BLOCK
      APR_READ_BLOCK
      APR_WRITE_BLOCK
      APR_FULL_NONBLOCK
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd>
<dd>
Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. Use this function rather than apr_file_pipe_create to create pipes where one or both ends require non-blocking semantics.</dd></dl>
<p>Create a named pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the named pipe </td></tr>
    <tr><td class="paramname">perm</td><td>The permissions for the newly created pipe. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are getting a timeout for. </td></tr>
    <tr><td class="paramname">timeout</td><td>The current timeout value in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are setting a timeout on. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout value in microseconds. Values &lt; 0 mean wait forever, 0 means do not wait at all.</td></tr>
  </table>
  </dd>
</dl>
<p>file (un)locking functions. <br />
Establish a lock on the specified, open file. The lock may be advisory or mandatory, at the discretion of the platform. The lock applies to the file as a whole, rather than a specific range. Locks are established on a per-thread/process basis; a second lock by the same thread will not block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to lock. </td></tr>
    <tr><td class="paramname">type</td><td>The type of lock to establish on the file.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove any outstanding locks on the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to unlock.</td></tr>
  </table>
  </dd>
</dl>
<p>accessor and general file_io functions. <br />
return the file name of the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_path</td><td>The path of the file. <br />
</td></tr>
    <tr><td class="paramname">thefile</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the file. <br />
</td></tr>
    <tr><td class="paramname">key</td><td>The key to use for retrieving data associated with this file. </td></tr>
    <tr><td class="paramname">file</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The currently open file. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the file. <br />
</td></tr>
    <tr><td class="paramname">key</td><td>The key to use for associating data with the file. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the file is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>set the specified file's permission bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The file (name) to apply the permissions to. </td></tr>
    <tr><td class="paramname">perms</td><td>The permission bits to apply to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some platforms may not be able to apply all of the available permission bits; APR_INCOMPLETE will be returned if some permissions are specified which could not be set.</dd>
<dd>
Platforms which do not implement this feature will return APR_ENOTIMPL.</dd></dl>
<p>Set attributes of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">attributes</td><td>Or'd combination of <pre>
           APR_FILE_ATTR_READONLY   - make the file readonly
           APR_FILE_ATTR_EXECUTABLE - make the file executable
           APR_FILE_ATTR_HIDDEN     - make the file hidden
</pre> </td></tr>
    <tr><td class="paramname">attr_mask</td><td>Mask of valid bits in attributes. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function should be used in preference to explicit manipulation of the file permissions, because the operations to provide these attributes are platform specific and may involve more than simply setting permission bits. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return APR_ENOTIMPL.</dd></dl>
<p>Set the mtime of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">mtime</td><td>The mtime to apply to the file. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return APR_ENOTIMPL.</dd></dl>
<p>Create a new directory on the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new directory on the file system, but behaves like 'mkdir -p'. Creates intermediate directories as required. No error will be reported if PATH already exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove directory from the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be removed. (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removing a directory which is in-use (e.g., the current working directory, or during apr_dir_read, or with an open file) is not portable.</dd></dl>
<p>get the specified file's stats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>Where to store the information about the file. </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">thefile</td><td>The file to get information about.</td></tr>
  </table>
  </dd>
</dl>
<p>Truncate the file's length to the specified offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The file to truncate </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to truncate to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The read/write file offset is repositioned to offset.</dd></dl>
<p>Open a temporary file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The apr file to use as a temporary file. </td></tr>
    <tr><td class="paramname">templ</td><td>The template to use when creating a temp file. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. If this is zero, the file is opened with APR_CREATE | APR_READ | APR_WRITE | APR_EXCL | APR_DELONCLOSE </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate the file out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><br />
This function generates a unique temporary file name from template. <br />
The last six characters of template must be XXXXXX and these are replaced with a string that makes the filename unique. Since it will be modified, template must not be a string constant, but should be declared as a character array.</dd></dl>
<p>Find an existing directory suitable as a temporary storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_dir</td><td>The temp directory. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for any necessary allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><br />
This function uses an algorithm to search for a directory that an an application can use for temporary storage.</dd></dl>
<p>Determine if the given pattern is a regular expression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to search for glob characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if pattern has any glob characters in it</dd></dl>
<p>Find all files that match a specified pattern. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to use for finding files. </td></tr>
    <tr><td class="paramname">result</td><td>Array to use when storing the results </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if pattern has any glob characters in it</dd></dl>
<p>Set up an application with normalized argc, argv (and optionally env) in order to deal with platform-specific oddities, such as Win32 services, code pages and signals. This must be the first function called for any APR program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Pointer to the argc that may be corrected </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the argv that may be corrected </td></tr>
    <tr><td class="paramname">env</td><td>Pointer to the env that may be corrected, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See apr_initialize if this is a library consumer of apr. Otherwise, this call is identical to apr_initialize, and must be closed with a call to apr_terminate at the end of program execution.</dd></dl>
<p>Parse the options initialized by apr_getopt_init(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The apr_opt_t structure returned by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A string of characters that are acceptable options to the program. Characters followed by ":" are required to have an option associated </td></tr>
    <tr><td class="paramname">option_ch</td><td>The next option character parsed </td></tr>
    <tr><td class="paramname">option_arg</td><td>The argument following the option character: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      &ndash;  No more options to parse
            APR_BADCH    &ndash;  Found a bad option character
            APR_BADARG   &ndash;  No argument followed the option flag
            APR_SUCCESS  &ndash;  The next option was found.
</pre></dd></dl>
<p>Parse the options initialized by apr_getopt_init(), accepting long options beginning with "--" in addition to single-character options beginning with "-". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The <a class="el" href="structapr__getopt__t.html">apr_getopt_t</a> structure created by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A pointer to a list of <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structures, which can be initialized with { "name", optch, has_args }. has_args is nonzero if the option requires an argument. A structure with an optch value of 0 terminates the list. </td></tr>
    <tr><td class="paramname">option_ch</td><td>Receives the value of "optch" from the <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structure corresponding to the next option matched. </td></tr>
    <tr><td class="paramname">option_arg</td><td>Receives the argument following the option, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      --  No more options to parse
            APR_BADCH    --  Found a bad option character
            APR_BADARG   --  No argument followed the option flag
            APR_SUCCESS  --  The next option was found.
</pre> When APR_SUCCESS is returned, os-&gt;ind gives the index of the first non-option argument. On error, a message will be printed to stdout unless os-&gt;err is set to 0. If os-&gt;interleave is set to nonzero, options can come after arguments, and os-&gt;argv will be permuted to leave non-option arguments at the end (the original argv is unaffected).</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_global_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Display a prompt and read in the password from stdin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prompt</td><td>The prompt to display </td></tr>
    <tr><td class="paramname">pwbuf</td><td>Buffer to store the password </td></tr>
    <tr><td class="paramname">bufsize</td><td>The length of the password buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the password entered must be truncated to fit in the provided buffer, APR_ENAMETOOLONG will be returned. Note that the bufsize paramater is passed by reference for no reason; its value will never be modified by the apr_password_get() function.</dd></dl>
<p>Shutdown either reading, writing, or both sides of a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close </td></tr>
    <tr><td class="paramname">how</td><td>How to shutdown the socket. One of: <pre>
           APR_SHUTDOWN_READ         no longer allow read requests
           APR_SHUTDOWN_WRITE        no longer allow write requests
           APR_SHUTDOWN_READWRITE    no longer allow read or write requests 
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__network__io.html#gae2130f1fa2d0db58c5c3c9c73d9b4009">apr_shutdown_how_e</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually close the socket descriptor, it just controls which calls are still valid on the socket.</dd></dl>
<p>Close a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close</td></tr>
  </table>
  </dd>
</dl>
<p>Bind the socket to its associated port </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to bind </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This may be where we will find out if there is any other process using the selected port.</dd></dl>
<p>Listen to a bound socket for connections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to listen on </td></tr>
    <tr><td class="paramname">backlog</td><td>The number of outstanding connections allowed in the sockets listen queue. If this value is less than zero, the listen queue size is set to zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Accept a new connection request </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sock</td><td>A copy of the socket that is connected to the socket that made the connection request. This is the socket which should be used for all future communication. </td></tr>
    <tr><td class="paramname">sock</td><td>The socket we are listening on. </td></tr>
    <tr><td class="paramname">connection_pool</td><td>The pool for the new socket.</td></tr>
  </table>
  </dd>
</dl>
<p>Issue a connection request to a socket either on the same machine or a different one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket we wish to use for our side of the connection </td></tr>
    <tr><td class="paramname">sa</td><td>The address of the machine we wish to connect to.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine whether the receive part of the socket has been closed by the peer (such that a subsequent call to apr_socket_read would return APR_EOF), if the socket's receive buffer is empty. This function does not block waiting for I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to check </td></tr>
    <tr><td class="paramname">atreadeof</td><td>If APR_SUCCESS is returned, *atreadeof is set to non-zero if a subsequent read would return APR_EOF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error is returned if it was not possible to determine the status, in which case *atreadeof is not changed.</dd></dl>
<p>Create <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> from hostname, address family, and port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The new <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">hostname</td><td>The hostname or numeric address string to resolve/parse, or NULL to build an address that corresponds to 0.0.0.0 or :: </td></tr>
    <tr><td class="paramname">family</td><td>The address family to use, or APR_UNSPEC if the system should decide. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags: <pre>
      APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look
                                for IPv6 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL; mutually exclusive with
                                APR_IPV6_ADDR_OK
      APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look
                                for IPv4 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL and APR_HAVE_IPV6; mutually exclusive
                                with APR_IPV4_ADDR_OK
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>The pool for the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Look up the host name from an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>The hostname. </td></tr>
    <tr><td class="paramname">sa</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags.</td></tr>
  </table>
  </dd>
</dl>
<p>Parse hostname/IP address with scope id and port.</p>
<p>Any of the following strings are accepted: 8080 (just the port number) www.apache.org (just the hostname) www.apache.org:8080 (hostname and port number)</p>
<p>[fe80::1eth0] (IPv6 numeric address string and scope id)</p>
<p>Invalid strings: (empty string) [abc] (not valid IPv6 numeric address string) abc:65536 (invalid port number)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The new buffer containing just the hostname. On output, *addr will be NULL if no hostname/IP address was specfied. </td></tr>
    <tr><td class="paramname">scope_id</td><td>The new buffer containing just the scope id. On output, *scope_id will be NULL if no scope id was specified. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. On output, *port will be 0 if no port was specified. <h3>FIXME: 0 is a legal port (per RFC 1700). this should</h3>
</td></tr>
  </table>
  </dd>
</dl>
<h3>return something besides zero if the port is missing.</h3>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string to be parsed. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which *addr and *scope_id are allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If scope id shouldn't be allowed, check for scope_id != NULL in addition to checking the return code. If addr/hostname should be required, check for addr == NULL in addition to checking the return code.</dd></dl>
<p>Get name of the current machine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to store the hostname in. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum length of the hostname that can be stored in the buffer provided. The suggested length is APRMAXHOSTLEN + 1. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the buffer was not large enough, an error will be returned.</dd></dl>
<p>Return the data associated with the current socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the user data. </td></tr>
    <tr><td class="paramname">sock</td><td>The currently open socket.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The currently open socket. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup to call when the socket is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>Send data over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to send; on exit, the number of bytes sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
socket option.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Send multiple packets of data over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">vec</td><td>The array of iovec structs containing the data to send </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of iovec structs in the array </td></tr>
    <tr><td class="paramname">len</td><td>Receives the number of bytes actually written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
socket option.
The number of bytes actually sent is stored in argument 3.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send from </td></tr>
    <tr><td class="paramname">where</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> describing where to send the data </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The data to send </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to send</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from a socket. On success, the address of the peer from which the data was sent is copied into the <em>from</em> parameter, and the <em>len</em> parameter is updated to give the number of bytes written to <em>buf</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Updated with the address from which the data was received </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to use </td></tr>
    <tr><td class="paramname">len</td><td>The length of the available buffer</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to read the data from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to receive; on exit, the number of bytes received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking read by default.  To change 
this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
socket option.
The number of bytes actually received is stored in argument 3.</pre></dd></dl>
<p>It is possible for both bytes to be received and an APR_EOF or other error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Setup socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to configure. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
                                 When this option is enabled, use
                                 the <a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#ga9dd578bfcd76a2d997395608ae5b3a4e">APR_STATUS_IS_EAGAIN()</a> macro to
                                 see if a send or receive function
                                 could not transfer data without
                                 blocking.
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Value for the option.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">t</td><td>Value for the timeout. <pre>
  t &gt; 0  &ndash; read and write calls return APR_TIMEUP if specified time
            elapsess with no data read or written
  t == 0 &ndash; read and write calls never block
  t &lt; 0  &ndash; read and write calls block
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Query socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to query. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
           APR_SO_DISCONNECTED -- Query the disconnected state of the socket.
                                 (Currently only used on Windows)
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Socket option returned on the call.</td></tr>
  </table>
  </dd>
</dl>
<p>Query socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">t</td><td>Socket timeout returned from the query.</td></tr>
  </table>
  </dd>
</dl>
<p>Query the specified socket if at the OOB/Urgent data mark </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">atmark</td><td>Is set to true if socket is at the OOB/urgent mark, otherwise is set to false.</td></tr>
  </table>
  </dd>
</dl>
<p>Return an address associated with a socket; either the address to which the socket is bound locally or the the address of the peer to which the socket is connected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The returned <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">which</td><td>Whether to retrieve the local or remote address </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the IP address (in numeric address string format) in an APR socket address. APR will allocate storage for the IP address string from the pool of the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The IP address. </td></tr>
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the IP address (in numeric address string format) of the APR socket address <em>sockaddr</em> into the buffer <em>buf</em> (of size <em>buflen</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>See if the IP addresses in two APR socket addresses are equivalent. Appropriate logic is present for comparing IPv4-mapped IPv6 addresses with IPv4 addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr1</td><td>One of the APR socket addresses. </td></tr>
    <tr><td class="paramname">addr2</td><td>The other APR socket address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return value will be non-zero if the addresses are equivalent.</dd></dl>
<p>Return the type of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">type</td><td>The returned type (e.g., SOCK_STREAM).</td></tr>
  </table>
  </dd>
</dl>
<p>Given an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and a service name, set the port for the service </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> that will have its port set </td></tr>
    <tr><td class="paramname">servname</td><td>The name of the service you wish to use</td></tr>
  </table>
  </dd>
</dl>
<p>Build an ip-subnet representation from an IP address and optional netmask or number-of-bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The new ip-subnet representation </td></tr>
    <tr><td class="paramname">ipstr</td><td>The input IP address string </td></tr>
    <tr><td class="paramname">mask_or_numbits</td><td>The input netmask or number-of-bits string, or NULL </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate from</td></tr>
  </table>
  </dd>
</dl>
<p>Test the IP address in an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> against a pre-built ip-subnet representation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The ip-subnet representation </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the socket address is within the subnet, 0 otherwise</dd></dl>
<p>Return the protocol of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">protocol</td><td>The returned protocol (e.g., APR_PROTO_TCP).</td></tr>
  </table>
  </dd>
</dl>
<p>Join a Multicast Group </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to join a multicast group </td></tr>
    <tr><td class="paramname">join</td><td>The address of the multicast group to join </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Leave a Multicast Group. All arguments must be the same as apr_mcast_join. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to leave a multicast group </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the multicast group to leave </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Multicast Time to Live (ttl) for a multicast transmission. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast ttl </td></tr>
    <tr><td class="paramname">ttl</td><td>Time to live to Assign. 0-255, default=1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the TTL is 0, packets will only be seen by sockets on the local machine, and only when multicast loopback is enabled.</dd></dl>
<p>Toggle IP Multicast Loopback </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set multicast loopback </td></tr>
    <tr><td class="paramname">opt</td><td>0=disable, 1=enable</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Interface to be used for outgoing Multicast Transmissions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast interface on </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use for Multicast</td></tr>
  </table>
  </dd>
</dl>
<p>Set up a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that this pollset can hold </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollset </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollset. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_THREADSAFE, then a pollset is created on which it is safe to make concurrent calls to apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from separate threads. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_WAKEABLE, then a pollset is created with additional internal pipe object used for the apr_pollset_wakeup() call. The actual size of pollset is in that case size + 1. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_NOCOPY, then the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures passed to apr_pollset_add() are not copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Some poll methods (including APR_POLLSET_KQUEUE, APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a fixed limit on the size of the pollset. For these methods, the size parameter controls the maximum number of descriptors that will be returned by a single call to apr_pollset_poll().</dd></dl>
<p>Destroy a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to destroy</td></tr>
  </table>
  </dd>
</dl>
<p>Add a socket or file descriptor to a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollset_poll(). </dd>
<dd>
If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_add() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically include the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
If the pollset has been created with APR_POLLSET_NOCOPY, the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structure referenced by descriptor will not be copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollset multiple times, even if the requested events differ for the different calls to apr_pollset_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollset with apr_pollset_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_remove() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically exclude the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
apr_pollset_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
    <tr><td class="paramname">num</td><td>Number of signalled descriptors (output parameter) </td></tr>
    <tr><td class="paramname">descriptors</td><td>Array of signalled descriptors (output parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>APR_EINTR will be returned if the pollset has been created with APR_POLLSET_WAKEABLE, apr_pollset_wakeup() has been called while waiting for activity, and there were no signalled descriptors at the time of the wakeup call. </dd>
<dd>
Multiple signalled conditions for the same descriptor may be reported in one or more returned <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures, depending on the implementation. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </dd></dl>
<p>Interrupt the blocked apr_pollset_poll() call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollset was not created with APR_POLLSET_WAKEABLE the return value is APR_EINIT.</dd></dl>
<p>Poll the descriptors in the poll structure </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprset</td><td>The poll structure we will be using. </td></tr>
    <tr><td class="paramname">numsock</td><td>The number of descriptors we are polling </td></tr>
    <tr><td class="paramname">nsds</td><td>The number of descriptors signalled (output parameter) </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The number of descriptors signalled is returned in the third argument. This is a blocking call, and it will not return until either a descriptor has been signalled or the timeout has expired. </dd>
<dd>
The rtnevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> array will only be filled- in if the return value is APR_SUCCESS. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Pollcb is only supported on some platforms; the apr_pollcb_create() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Pollcb is only supported on some platforms; the apr_pollcb_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Add a socket or file descriptor to a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollcb_poll(). </dd>
<dd>
Unlike the apr_pollset API, the descriptor is not copied, and users must retain the memory used by descriptor, as the same pointer will be returned to them from apr_pollcb_poll. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollcb multiple times, even if the requested events differ for the different calls to apr_pollcb_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollcb with apr_pollcb_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_pollcb_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled. </td></tr>
    <tr><td class="paramname">func</td><td>Callback function to call for each active descriptor. </td></tr>
    <tr><td class="paramname">baton</td><td>Opaque baton passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Multiple signalled conditions for the same descriptor may be reported in one or more calls to the callback function, depending on the implementation. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </dd></dl>
<p>Create a new pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the apr_pool_t will be a sub-pool. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL the allocator of the parent pool will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread-safe, in the sense that multiple threads can safely create subpools of the same parent pool concurrently. Similarly, a subpool can be created by one thread at the same time that another thread accesses the parent pool.</dd></dl>
<p>Create a new pool. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex.</dd></dl>
<p>Create a new unmanaged pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL a new allocator will be crated with newpool as owner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unmanaged pool is a special pool without a parent; it will NOT be destroyed upon apr_terminate. It must be explicitly destroyed by calling apr_pool_destroy, to prevent memory leaks. Use of this function is discouraged, think twice about whether you really really need it.</dd></dl>
<p>Debug version of apr_pool_create_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_create_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_ex in a wrapper, trust the macro and don't call apr_pool_create_ex_debug directly.</dd></dl>
<p>Debug version of apr_pool_create_core_ex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex_debug.</dd></dl>
<p>Debug version of apr_pool_create_unmanaged_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_create_unmanaged_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_core_ex in a wrapper, trust the macro and don't call apr_pool_create_core_ex_debug directly.</dd></dl>
<p>Determine if pool a is an ancestor of pool b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to search </td></tr>
    <tr><td class="paramname">b</td><td>The pool to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a is an ancestor of b, NULL is considered an ancestor of all pools. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if compiled with APR_POOL_DEBUG, this function will also return true if A is a pool which has been guaranteed by the caller (using apr_pool_join) to have a lifetime at least as long as some ancestor of pool B.</dd></dl>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The data to be attached to the pool should have a life span at least as long as the pool it is being attached to.</dd></dl>
<p>Users of APR must take EXTREME care when choosing a key to use for their data. It is possible to accidentally overwrite data by choosing a key that another part of the program is using. Therefore it is advised that steps are taken to ensure that unique keys are used for all of the userdata objects in a particular pool (the same key in two different pools or a pool and one of its subpools is okay) at all times. Careful namespace prefixing of key names is a typical way to help ensure this uniqueness.</p>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>same as apr_pool_userdata_set(), except that this version doesn't make a copy of the key (this function is useful, for example, when the key is a string literal) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should NOT be used if the key could change addresses by any means between the apr_pool_userdata_setn() call and a subsequent apr_pool_userdata_get() on that key, such as if a static string is used as a userdata key in a DSO and the DSO could be unloaded and reloaded between the _setn() and the _get(). You MUST use apr_pool_userdata_set() in such cases. </dd>
<dd>
More generally, the key and the data to be attached to the pool should have a life span at least as long as the pool itself.</dd></dl>
<p>Return the data associated with the current pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key for the data to retrieve </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool.</td></tr>
  </table>
  </dd>
</dl>
<p>Run the specified cleanup function immediately and unregister it.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>cleanup</em> will be removed and <em>cleanup</em> will be called with <em>data</em> as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to remove the cleanup from </td></tr>
    <tr><td class="paramname">data</td><td>The data to remove from cleanup </td></tr>
    <tr><td class="paramname">cleanup</td><td>The function to remove from cleanup</td></tr>
  </table>
  </dd>
</dl>
<p>convert the file from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The os specific file we are converting to </td></tr>
    <tr><td class="paramname">file</td><td>The apr file to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to get a file descriptor from an apr file type.</dd></dl>
<p>convert the dir from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>The os specific dir we are converting to </td></tr>
    <tr><td class="paramname">dir</td><td>The apr dir to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the socket from an apr type to an OS specific socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesock</td><td>The socket to convert. </td></tr>
    <tr><td class="paramname">sock</td><td>The os specific equivalent of the apr socket..</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from os specific type to apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the exploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Get the imploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shm from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osshm</td><td>The os specific shm representation </td></tr>
    <tr><td class="paramname">shm</td><td>The apr shm to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific file to convert </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that were used to open this file. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">register_cleanup</td><td>A cleanup will be registered on the <a class="el" href="structapr__file__t.html">apr_file_t</a> to issue apr_file_close(). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the dir from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The apr dir we are converting to. </td></tr>
    <tr><td class="paramname">thedir</td><td>The os specific dir to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use when creating to apr directory.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a socket from the os specific type to the apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The pool to use. </td></tr>
    <tr><td class="paramname">thesock</td><td>The socket to convert to. </td></tr>
    <tr><td class="paramname">cont</td><td>The socket we are converting to an apr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If it is a true socket, it is best to call apr_os_sock_make() and provide APR with more information about the socket.</dd></dl>
<p>Create a socket from an existing descriptor and local and remote socket addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apr_sock</td><td>The new socket that has been set up </td></tr>
    <tr><td class="paramname">os_sock_info</td><td>The os representation of the socket handle and other characteristics of the socket </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you only know the descriptor/handle or if it isn't really a true socket, use apr_os_sock_put() instead.</dd></dl>
<p>Convert the proc mutex from os specific type to apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex to convert. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>Put the imploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>Put the exploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shared memory from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm</td><td>The apr shm representation of osshm </td></tr>
    <tr><td class="paramname">osshm</td><td>The os specific shm identity </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On fork()ed architectures, this is typically nothing more than the memory block mapped. On non-fork architectures, this is typically some internal handle to pass the mapping from process to process.</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_proc_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is generally used to kill a cleanup on an already created mutex</dd></dl>
<p>Generate cryptographically secure random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state </td></tr>
    <tr><td class="paramname">random</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the cryptographic PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The RNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The PRNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Remove named resource associated with a shared memory segment, preventing attachments to the resource, but not destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename associated with shared-memory segment which needs to be removed </td></tr>
    <tr><td class="paramname">pool</td><td>The pool used for file operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is only supported on platforms which support name-based shared memory segments, and will return APR_ENOTIMPL on platforms without such support. Removing the file while the shm is in use is not entirely portable, caller may use this to enhance obscurity of the resource, but be prepared for the the call to fail, and for concurrent attempts to create a resource of the same name to also fail. The pool cleanup of apr_shm_create (apr_shm_destroy) also removes the named resource.</dd></dl>
<p>Destroy a shared memory segment and associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory segment structure to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Attach to a shared memory segment that was created by another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">filename</td><td>The file used to create the original segment. (This MUST match the original filename.) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure for this process.</td></tr>
  </table>
  </dd>
</dl>
<p>Detach from a shared memory segment without destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure representing the segment to detach from.</td></tr>
  </table>
  </dd>
</dl>
<p>Enable the delivery of a particular signal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signum</td><td>The signal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status</dd></dl>
<p>Do a natural order comparison of two strings ignoring the case of the strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first string to compare </td></tr>
    <tr><td class="paramname">b</td><td>The second string to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either &lt;0, 0, or &gt;0. If the first string is less than the second this returns &lt;0, if they are equivalent it returns 0, and if the first string is greater than second string it retuns &gt;0.</dd></dl>
<p>Convert the arguments to a program from one string to an array of strings terminated by a NULL pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg_str</td><td>The arguments to convert </td></tr>
    <tr><td class="paramname">argv_out</td><td>Output location. This is a pointer to an array of strings. </td></tr>
    <tr><td class="paramname">token_context</td><td>Pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>vsnprintf routine based on apr_vformatter. This means it understands the same extensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write to </td></tr>
    <tr><td class="paramname">len</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">format</td><td>The format string </td></tr>
    <tr><td class="paramname">ap</td><td>The arguments to use to fill out the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a numeric string into an apr_off_t numeric value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The value of the parsed string. </td></tr>
    <tr><td class="paramname">buf</td><td>The string to parse. It may contain optional whitespace, followed by an optional '+' (positive, default) or '-' (negative) character, followed by an optional '0x' prefix if base is 0 or 16, followed by numeric digits appropriate for base. </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the valid character in buf. If not NULL, it is set to the first invalid character in buf. </td></tr>
    <tr><td class="paramname">base</td><td>A numeric base in the range between 2 and 36 inclusive, or 0. If base is zero, buf will be treated as base ten unless its digits are prefixed with '0x', in which case it will be treated as base 16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </dd></dl>
<p>Determine if the array is empty (either NULL or having no elements). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if empty, False otherwise</dd></dl>
<p>Iterate over a table running the provided function once for every element in the table. The</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vp</td><td>varargs parameter must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the</td></tr>
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function returns zero, iteration will continue using the next specified key, if any.</td></tr>
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">t</td><td>The table to iterate over </td></tr>
    <tr><td class="paramname">vp</td><td>List of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the comp() iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__tables.html#ga633325e16f9e1f81adce476fb71cbd88">apr_table_do_callback_fn_t</a></dd></dl>
<p>Determine if any of stdin, stdout, or stderr should be linked to pipes when starting a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">in</td><td>Should stdin be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">out</td><td>Should stdout be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">err</td><td>Should stderr be a pipe back to the parent? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If APR_NO_PIPE, there will be no special channel, the child inherits the parent's corresponding stdio stream. If APR_NO_FILE is specified, that corresponding stream is closed in the child (and will be INVALID_HANDLE_VALUE when inspected on Win32). This can have ugly side effects, as the next file opened in the child on Unix will fall into the stdio stream fd slot!</dd></dl>
<p>Set the child_in and/or parent_in values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_in. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_in. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. You can save some extra function calls by not creating your own pipe since this creates one in the process space for you. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_out and parent_out values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_out. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_out. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_err and parent_err values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_err. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_err. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set which directory the child process should start executing in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">dir</td><td>Which dir to start in. By default, this is the same dir as the parent currently resides in, when the createprocess call is made.</td></tr>
  </table>
  </dd>
</dl>
<p>Set what type of command the child process will call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">cmd</td><td>The type of command. One of: <pre>
           APR_SHELLCMD     &ndash;  Anything that the shell can handle
           APR_PROGRAM      &ndash;  Executable program   (default) 
           APR_PROGRAM_ENV  &ndash;  Executable program, copy environment
           APR_PROGRAM_PATH &ndash;  Executable program on PATH, copy env
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Determine if the child should start in detached state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">detach</td><td>Should the child start in detached state? Default is no.</td></tr>
  </table>
  </dd>
</dl>
<p>Specify an error function to be called in the child process if APR encounters an error in the child prior to running the specified program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">errfn</td><td>The function to call in the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>At the present time, it will only be called from apr_proc_create() on platforms where fork() is used. It will never be called on other platforms, on those platforms apr_proc_create() will return the error in the parent process rather than invoke the callback in the now-forked child process.</dd></dl>
<p>Specify that apr_proc_create() should do whatever it can to report failures to the caller of apr_proc_create(), rather than find out in the child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">chk</td><td>Flag to indicate whether or not extra work should be done to try to report failures to the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This flag only affects apr_proc_create() on platforms where fork() is used. This leads to extra overhead in the calling process, but that may help the application handle such errors more gracefully.</dd></dl>
<p>Determine if the child should start in its own address space or using the current one from its parent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">addrspace</td><td>Should the child start in its own address space? Default is no on NetWare and yes on other platforms.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the username used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">username</td><td>The username used </td></tr>
    <tr><td class="paramname">password</td><td>User password if needed. Password is needed on WIN32 or any other platform having APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the group used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">groupname</td><td>The group name used</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new process and execute a new program within that process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_proc</td><td>The resulting process handle. </td></tr>
    <tr><td class="paramname">progname</td><td>The program to run </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to the new program. The first one should be the program name. </td></tr>
    <tr><td class="paramname">env</td><td>The new environment table for the new process. This should be a list of NULL-terminated strings. This argument is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and APR_SHELLCMD_ENV types of commands. </td></tr>
    <tr><td class="paramname">attr</td><td>the procattr we should use to determine how to create the new process </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function returns without waiting for the new process to terminate; use apr_proc_wait for that.</dd></dl>
<p>Wait for a child process to die </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process handle that corresponds to the desired child process </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The childs status is in the return code to this process. It is one of: <pre>
           APR_CHILD_DONE     &ndash; child is no longer running.
           APR_CHILD_NOTDONE  &ndash; child is still running.
</pre></dd></dl>
<p>Wait for any current child process to die and return information about that child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Pointer to NULL on entry, will be filled out with child's information </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>Pool to allocate child information out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000010">Bug:</a></b></dt><dd>Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0 </dd></dl>
<p>Detach the process from the controlling terminal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">daemonize</td><td>set to non-zero if the process should daemonize and become a background process, else it will stay in the foreground.</td></tr>
  </table>
  </dd>
</dl>
<p>Notify the maintenance callback of a registered other child process that application has detected an event, such as death. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to check </td></tr>
    <tr><td class="paramname">reason</td><td>The reason code to pass to the maintenance function </td></tr>
    <tr><td class="paramname">status</td><td>The status to pass to the maintenance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An example of code using this behavior; <pre>
rv = apr_proc_wait_all_procs(&amp;proc, &amp;exitcode, &amp;status, APR_WAIT, p);
if (<a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#ga1e6539dfa172cef4026105ca33b2b208">APR_STATUS_IS_CHILD_DONE(rv)</a>) {
#if APR_HAS_OTHER_CHILD
    if (apr_proc_other_child_alert(&amp;proc, APR_OC_REASON_DEATH, status)
            == APR_SUCCESS) {
        ;  (already handled)
    }
    else
#endif
        [... handling non-otherchild processes death ...]
</pre></dd></dl>
<p>Terminate a process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to terminate. </td></tr>
    <tr><td class="paramname">sig</td><td>How to kill the process.</td></tr>
  </table>
  </dd>
</dl>
<p>convert a time to its human readable components using an offset from GMT </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode </td></tr>
    <tr><td class="paramname">offs</td><td>the number of seconds offset to apply</td></tr>
  </table>
  </dd>
</dl>
<p>convert a time to its human readable components in GMT timezone </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>convert a time to its human readable components in local timezone </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t e.g. elapsed usec since epoch </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t that always represents GMT </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>apr_rfc822_date formats dates in the RFC822 format in an efficient manner. It is a fixed length format which requires the indicated amount of storage, including the trailing NUL terminator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>apr_ctime formats dates in the ctime() format in an efficient manner. it is a fixed length format and requires the indicated amount of storage including the trailing NUL terminator. Unlike ANSI/ISO C ctime(), apr_ctime() does not include a <br />
 at the end of the string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>formats the exploded time according to the format specified </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to write to </td></tr>
    <tr><td class="paramname">retsize</td><td>The length of the returned string </td></tr>
    <tr><td class="paramname">max</td><td>The maximum length of the string </td></tr>
    <tr><td class="paramname">format</td><td>The format for the time string </td></tr>
    <tr><td class="paramname">tm</td><td>The time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>An APR internal function for fast ucs-2 wide Unicode format conversion to the utf-8 octet-encoded Unicode. This function is used for filename and other resource conversions for platforms providing native Unicode support.</p>
<p>Only the errors APR_EINVAL and APR_INCOMPLETE may occur, the former when the character code is invalid (in or out of context) and the later when more words were expected, but insufficient words remain.</p>
<p>Get the value of an environment variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the returned value, allocated from <em>pool</em> </td></tr>
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate <em>value</em> and any temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Set the value of an environment variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Delete a variable from the environment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>get the specified file's stats. The file is specified by filename, instead of using a pre-opened file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>Where to store the information about the file, which is never touched if the call fails. </td></tr>
    <tr><td class="paramname">fname</td><td>The name of the file to stat. </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use to allocate the new file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>APR_INCOMPLETE</code> is returned all the fields in <em>finfo</em> may not be filled in, and you need to check the <code>finfo-&gt;valid</code> bitmask to verify that what you're looking for is there.</dd></dl>
<p>Open the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_dir</td><td>The opened directory descriptor. </td></tr>
    <tr><td class="paramname">dirname</td><td>The full path to the directory (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>close the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Read the next entry from the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>the file info structure and filled in by apr_dir_read </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">thedir</td><td>the directory descriptor returned from apr_dir_open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>No ordering is guaranteed for the entries read.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>APR_INCOMPLETE</code> is returned all the fields in <em>finfo</em> may not be filled in, and you need to check the <code>finfo-&gt;valid</code> bitmask to verify that what you're looking for is there. When no more entries are available, APR_ENOENT is returned.</dd></dl>
<p>Rewind the directory to the first entry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to rewind.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the rootpath from the given filepath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootpath</td><td>the root file path returned with APR_SUCCESS or APR_EINCOMPLETE </td></tr>
    <tr><td class="paramname">filepath</td><td>the pathname to parse for its root component </td></tr>
    <tr><td class="paramname">flags</td><td>the desired rules to apply, from <pre>
     APR_FILEPATH_NATIVE    Use native path seperators (e.g. '\' on Win32)
     APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>on return, filepath points to the first non-root character in the given filepath. In the simplest example, given a filepath of "/foo", returns the rootpath of "/" and filepath points at "foo". This is far more complex on other platforms, which will canonicalize the root form to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also test for the validity of that root (e.g., that a drive d:/ or network share //machine/foovol/). The function returns APR_ERELATIVE if filepath isn't rooted (an error), APR_EINCOMPLETE if the root path is ambigious (but potentially legitimate, e.g. "/" on Windows is incomplete because it doesn't specify the drive letter), or APR_EBADPATH if the root is simply invalid. APR_SUCCESS is returned if filepath is an absolute path.</dd></dl>
<p>Merge additional file path onto the previously processed rootpath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpath</td><td>the merged paths returned </td></tr>
    <tr><td class="paramname">rootpath</td><td>the root file path (NULL uses the current working path) </td></tr>
    <tr><td class="paramname">addpath</td><td>the path to add to the root path </td></tr>
    <tr><td class="paramname">flags</td><td>the desired APR_FILEPATH_ rules to apply when merging </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the flag APR_FILEPATH_TRUENAME is given, and the addpath contains wildcard characters ('*', '?') on platforms that don't support such characters within filenames, the paths will be merged, but the result code will be APR_EPATHWILD, and all further segments will not reflect the true filenames including the wildcard and following segments.</dd></dl>
<p>Split a search path into separate components </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathelts</td><td>the returned components of the search path </td></tr>
    <tr><td class="paramname">liststr</td><td>the search path (e.g., <code>getenv("PATH")</code>) </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the array and path components from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>empty path componenta do not become part of <em>pathelts</em>. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Merge a list of search path components into a single search path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">liststr</td><td>the returned search path; may be NULL if <em>pathelts</em> is empty </td></tr>
    <tr><td class="paramname">pathelts</td><td>the components of the search path </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the search path from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>emtpy strings in the source array are ignored. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Return the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path string returned </td></tr>
    <tr><td class="paramname">flags</td><td>optional flag APR_FILEPATH_NATIVE to retrieve the default file path in os-native format. </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the default path string from</td></tr>
  </table>
  </dd>
</dl>
<p>Set the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path returned </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the encoding used internally by the FilePath functions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>points to a variable which receives the encoding style flag </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <code>apr_os_locale_encoding</code> and/or <code>apr_os_default_encoding</code> to get the name of the path encoding if it's not UTF-8.</dd></dl>
<p>Open the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newf</td><td>The opened file descriptor. </td></tr>
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">flag</td><td>Or'ed value of: <pre>
        APR_READ              open for reading
        APR_WRITE             open for writing
        APR_CREATE            create the file if not there
        APR_APPEND            file ptr is set to end prior to all writes
        APR_TRUNCATE          set length to zero if file exists
        APR_BINARY            not a text file (This flag is ignored on 
                              UNIX because it has no meaning)
        APR_BUFFERED          buffer the data.  Default is non-buffered
        APR_EXCL              return error if APR_CREATE and file exists
        APR_DELONCLOSE        delete the file after closing.
        APR_XTHREAD           Platform dependent tag to open the file
                              for use across multiple threads
        APR_SHARELOCK         Platform dependent support for higher
                              level locked read/write access to support
                              writes across process/machines
        APR_FILE_NOCLEANUP    Do not register a cleanup with the pool 
                              passed in on the <em>pool</em> argument (see below).
                              The apr_os_file_t handle in <a class="el" href="structapr__file__t.html">apr_file_t</a> will not
                              be closed when the pool is destroyed.
        APR_SENDFILE_ENABLED  Open with appropriate platform semantics
                              for sendfile operations.  Advisory only,
                              apr_socket_sendfile does not check this flag.
</pre> </td></tr>
    <tr><td class="paramname">perm</td><td>Access permissions for file. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If perm is APR_OS_DEFAULT and the file is being created, appropriate default permissions will be used. </dd>
<dd>
By default, the returned file descriptor will not be inherited by child processes created by apr_proc_create(). This can be changed using apr_file_inherit_set().</dd></dl>
<p>Close the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the file is open, it won't be removed until all instances are closed.</dd></dl>
<p>Rename the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If a file exists at the new location, then it will be overwritten. Moving files or directories across devices may not be possible.</dd></dl>
<p>Create a hard link to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Both files must reside on the same device.</dd></dl>
<p>Copy the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the new file if it is created. In place of the usual or'd combination of file permissions, the value APR_FILE_SOURCE_PERMS may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the new file already exists, its contents will be overwritten.</dd></dl>
<p>Append the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the source file (use / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the destination file (use / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the destination file if it is created. In place of the usual or'd combination of file permissions, the value APR_FILE_SOURCE_PERMS may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required.</dd></dl>
<p>Are we at the end of the file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fptr</td><td>The apr file we are testing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns APR_EOF if we are at the end of file, APR_SUCCESS otherwise.</dd></dl>
<p>Open standard error as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The only reason that the apr_file_open_std* functions exist is that you may not always have a stderr/out/in on Windows. This is generally a problem with newer versions of Windows and services.</dd>
<dd>
The other problem is that the C library functions generally work differently on Windows and Unix. So, by using apr_file_open_std* functions, you can get a handle to an APR struct that works with the APR functions which are supposed to work identically on all platforms.</dd></dl>
<p>open standard output as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard input as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard error as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the APR_EXCL, APR_BUFFERED, APR_XTHREAD, APR_SHARELOCK, APR_SENDFILE_ENABLED and APR_LARGEFILE flags should be used. The APR_WRITE flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard output as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the APR_EXCL, APR_BUFFERED, APR_XTHREAD, APR_SHARELOCK, APR_SENDFILE_ENABLED and APR_LARGEFILE flags should be used. The APR_WRITE flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>open standard input as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the APR_EXCL, APR_BUFFERED, APR_XTHREAD, APR_SHARELOCK, APR_SENDFILE_ENABLED and APR_LARGEFILE flags should be used. The APR_READ flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr.</dd></dl>
<p>Read data from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to read; on exit, the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, all of the available data is read. The third argument is modified to reflect the number of bytes read. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is not possible for both bytes to be read and an APR_EOF or other error to be returned. APR_EINTR is never returned.</dd></dl>
<p>Write data to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to write; on exit, the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, it will write as many as it can. The third argument is modified to reflect the * number of bytes written.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. APR_EINTR is never returned.</dd></dl>
<p>Write data from iovec array to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than APR_MAX_IOVEC_SIZE. If it isn't, the function will fail with APR_EINVAL. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible for both bytes to be written and an error to be returned. APR_EINTR is never returned.</dd>
<dd>
apr_file_writev is available even if the underlying operating system doesn't provide writev().</dd></dl>
<p>Read data from the specified file, ensuring that the buffer is filled before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>If non-NULL, this will contain the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, then the process/thread will block until it is available or EOF is reached. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is possible for both bytes to be read and an error to be returned. And if *bytes_read is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
APR_EINTR is never returned.</dd></dl>
<p>Write data to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">bytes_written</td><td>If non-NULL, set to the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, the process/thread will block until they can be written. Exceptional error such as "out of space" or "pipe closed" will terminate with an error.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. And if *bytes_written is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
APR_EINTR is never returned.</dd></dl>
<p>Write data from iovec array to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than APR_MAX_IOVEC_SIZE. If it isn't, the function will fail with APR_EINVAL. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_writev_full is available even if the underlying operating system doesn't provide writev().</dd></dl>
<p>Write a character into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a character from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to read into </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from</td></tr>
  </table>
  </dd>
</dl>
<p>Put a character back onto a specified stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a line from the specified file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The buffer to store the string in. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer will be NUL-terminated if any characters are stored. The newline at the end of the line will not be stripped.</dd></dl>
<p>Write the string into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Flush the file's buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to flush</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data and metadata to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Duplicate the specified file descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The structure to duplicate into. </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>*new_file must point to a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>, or point to NULL.</dd></dl>
<p>Duplicate the specified file descriptor and close the original </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The old file that is to be closed and reused </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>new_file MUST point at a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>. It cannot be NULL.</dd></dl>
<p>Move the specified file descriptor to a new pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>Pointer in which to return the new <a class="el" href="structapr__file__t.html">apr_file_t</a> </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to move </td></tr>
    <tr><td class="paramname">p</td><td>The pool to which the descriptor is to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike apr_file_dup2(), this function doesn't do an OS dup() operation on the underlying descriptor; it just moves the descriptor's <a class="el" href="structapr__file__t.html">apr_file_t</a> wrapper to a new pool. </dd>
<dd>
The new pool need not be an ancestor of old_file's pool. </dd>
<dd>
After calling this function, old_file may not be used</dd></dl>
<p>Give the specified apr file handle a new buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file handle that is to be modified </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible to add a buffer to previously unbuffered file handles, the APR_BUFFERED flag will be added to the file handle's flags. Likewise, with buffer=NULL and bufsize=0 arguments it is possible to make a previously buffered file handle unbuffered.</dd></dl>
<p>Move the read/write file offset to a specified byte within a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor </td></tr>
    <tr><td class="paramname">where</td><td>How to move the pointer, one of: <pre>
           APR_SET  --  set the offset to offset
           APR_CUR  --  add the offset to the current position 
           APR_END  --  add the offset to the current file size 
</pre> </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to move the pointer to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The third argument is modified to be the offset the pointer was actually moved to.</dd></dl>
<p>Create an anonymous pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_file_pipe_create_ex</dd></dl>
<p>Create an anonymous pipe which portably supports async timeout options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">blocking</td><td>one of these values defined in <a class="el" href="apr__thread__proc_8h.html" title="APR Thread and Process Library. ">apr_thread_proc.h</a>; </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. <pre>
      APR_FULL_BLOCK
      APR_READ_BLOCK
      APR_WRITE_BLOCK
      APR_FULL_NONBLOCK
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd>
<dd>
Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. Use this function rather than apr_file_pipe_create to create pipes where one or both ends require non-blocking semantics.</dd></dl>
<p>Create a named pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the named pipe </td></tr>
    <tr><td class="paramname">perm</td><td>The permissions for the newly created pipe. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are getting a timeout for. </td></tr>
    <tr><td class="paramname">timeout</td><td>The current timeout value in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are setting a timeout on. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout value in microseconds. Values &lt; 0 mean wait forever, 0 means do not wait at all.</td></tr>
  </table>
  </dd>
</dl>
<p>file (un)locking functions. <br />
Establish a lock on the specified, open file. The lock may be advisory or mandatory, at the discretion of the platform. The lock applies to the file as a whole, rather than a specific range. Locks are established on a per-thread/process basis; a second lock by the same thread will not block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to lock. </td></tr>
    <tr><td class="paramname">type</td><td>The type of lock to establish on the file.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove any outstanding locks on the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to unlock.</td></tr>
  </table>
  </dd>
</dl>
<p>accessor and general file_io functions. <br />
return the file name of the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_path</td><td>The path of the file. <br />
</td></tr>
    <tr><td class="paramname">thefile</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the file. <br />
</td></tr>
    <tr><td class="paramname">key</td><td>The key to use for retrieving data associated with this file. </td></tr>
    <tr><td class="paramname">file</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The currently open file. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the file. <br />
</td></tr>
    <tr><td class="paramname">key</td><td>The key to use for associating data with the file. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the file is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>set the specified file's permission bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The file (name) to apply the permissions to. </td></tr>
    <tr><td class="paramname">perms</td><td>The permission bits to apply to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some platforms may not be able to apply all of the available permission bits; APR_INCOMPLETE will be returned if some permissions are specified which could not be set.</dd>
<dd>
Platforms which do not implement this feature will return APR_ENOTIMPL.</dd></dl>
<p>Set attributes of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">attributes</td><td>Or'd combination of <pre>
           APR_FILE_ATTR_READONLY   - make the file readonly
           APR_FILE_ATTR_EXECUTABLE - make the file executable
           APR_FILE_ATTR_HIDDEN     - make the file hidden
</pre> </td></tr>
    <tr><td class="paramname">attr_mask</td><td>Mask of valid bits in attributes. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function should be used in preference to explicit manipulation of the file permissions, because the operations to provide these attributes are platform specific and may involve more than simply setting permission bits. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return APR_ENOTIMPL.</dd></dl>
<p>Set the mtime of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">mtime</td><td>The mtime to apply to the file. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return APR_ENOTIMPL.</dd></dl>
<p>Create a new directory on the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new directory on the file system, but behaves like 'mkdir -p'. Creates intermediate directories as required. No error will be reported if PATH already exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove directory from the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be removed. (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removing a directory which is in-use (e.g., the current working directory, or during apr_dir_read, or with an open file) is not portable.</dd></dl>
<p>get the specified file's stats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>Where to store the information about the file. </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">thefile</td><td>The file to get information about.</td></tr>
  </table>
  </dd>
</dl>
<p>Truncate the file's length to the specified offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The file to truncate </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to truncate to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The read/write file offset is repositioned to offset.</dd></dl>
<p>Open a temporary file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The apr file to use as a temporary file. </td></tr>
    <tr><td class="paramname">templ</td><td>The template to use when creating a temp file. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. If this is zero, the file is opened with APR_CREATE | APR_READ | APR_WRITE | APR_EXCL | APR_DELONCLOSE </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate the file out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><br />
This function generates a unique temporary file name from template. <br />
The last six characters of template must be XXXXXX and these are replaced with a string that makes the filename unique. Since it will be modified, template must not be a string constant, but should be declared as a character array.</dd></dl>
<p>Find an existing directory suitable as a temporary storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_dir</td><td>The temp directory. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for any necessary allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><br />
This function uses an algorithm to search for a directory that an an application can use for temporary storage.</dd></dl>
<p>Setup any APR internal data structures. This MUST be the first function called for any APR library. It is safe to call apr_initialize several times as long as apr_terminate is called the same number of times. </p><dl class="section remark"><dt>Remarks</dt><dd>See apr_app_initialize if this is an application, rather than a library consumer of apr.</dd></dl>
<p>Set up an application with normalized argc, argv (and optionally env) in order to deal with platform-specific oddities, such as Win32 services, code pages and signals. This must be the first function called for any APR program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Pointer to the argc that may be corrected </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the argv that may be corrected </td></tr>
    <tr><td class="paramname">env</td><td>Pointer to the env that may be corrected, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See apr_initialize if this is a library consumer of apr. Otherwise, this call is identical to apr_initialize, and must be closed with a call to apr_terminate at the end of program execution.</dd></dl>
<p>Initialize the arguments for parsing by apr_getopt(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The options structure created for apr_getopt() </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to operate on </td></tr>
    <tr><td class="paramname">argc</td><td>The number of arguments to parse </td></tr>
    <tr><td class="paramname">argv</td><td>The array of arguments to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Arguments 3 and 4 are most commonly argc and argv from main(argc, argv) The (*os)-&gt;errfn is initialized to fprintf(stderr... but may be overridden.</dd></dl>
<p>Parse the options initialized by apr_getopt_init(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The apr_opt_t structure returned by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A string of characters that are acceptable options to the program. Characters followed by ":" are required to have an option associated </td></tr>
    <tr><td class="paramname">option_ch</td><td>The next option character parsed </td></tr>
    <tr><td class="paramname">option_arg</td><td>The argument following the option character: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      &ndash;  No more options to parse
            APR_BADCH    &ndash;  Found a bad option character
            APR_BADARG   &ndash;  No argument followed the option flag
            APR_SUCCESS  &ndash;  The next option was found.
</pre></dd></dl>
<p>Parse the options initialized by apr_getopt_init(), accepting long options beginning with "--" in addition to single-character options beginning with "-". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The <a class="el" href="structapr__getopt__t.html">apr_getopt_t</a> structure created by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A pointer to a list of <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structures, which can be initialized with { "name", optch, has_args }. has_args is nonzero if the option requires an argument. A structure with an optch value of 0 terminates the list. </td></tr>
    <tr><td class="paramname">option_ch</td><td>Receives the value of "optch" from the <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structure corresponding to the next option matched. </td></tr>
    <tr><td class="paramname">option_arg</td><td>Receives the argument following the option, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      --  No more options to parse
            APR_BADCH    --  Found a bad option character
            APR_BADARG   --  No argument followed the option flag
            APR_SUCCESS  --  The next option was found.
</pre> When APR_SUCCESS is returned, os-&gt;ind gives the index of the first non-option argument. On error, a message will be printed to stdout unless os-&gt;err is set to 0. If os-&gt;interleave is set to nonzero, options can come after arguments, and os-&gt;argv will be permuted to leave non-option arguments at the end (the original argv is unaffected).</dd></dl>
<p>Create and initialize a mutex that can be used to synchronize both processes and threads. Note: There is considerable overhead in using this API if only cross-process or cross-thread mutual exclusion is required. See <a class="el" href="apr__proc__mutex_8h.html" title="APR Process Locking Routines. ">apr_proc_mutex.h</a> and <a class="el" href="apr__thread__mutex_8h.html" title="APR Thread Mutex Routines. ">apr_thread_mutex.h</a> for more specialized lock routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the memory address where the newly created mutex will be stored. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the lock mechanism requires one. This argument should always be provided. The lock code itself will determine if it should be used. </td></tr>
    <tr><td class="paramname">mech</td><td>The mechanism to use for the interprocess lock, if any; one of <pre>
           APR_LOCK_FCNTL
           APR_LOCK_FLOCK
           APR_LOCK_SYSVSEM
           APR_LOCK_POSIXSEM
           APR_LOCK_PROC_PTHREAD
           APR_LOCK_DEFAULT     pick the default mechanism for the platform
</pre> </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Check APR_HAS_foo_SERIALIZE defines to see if the platform supports APR_LOCK_foo. Only APR_LOCK_DEFAULT is portable.</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_global_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterate over a hash table running the provided function once for every element in the hash table. The</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the hash table.</td></tr>
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">ht</td><td>The hash table to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the comp() iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__hash.html#gafaf9b4435ab207b7708533cb8544face">apr_hash_do_callback_fn_t</a></dd></dl>
<p>apr_vformatter() is a generic printf-style formatting routine with some extensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_func</td><td>The function to call when the buffer is full </td></tr>
    <tr><td class="paramname">c</td><td>The buffer to write to </td></tr>
    <tr><td class="paramname">fmt</td><td>The format string </td></tr>
    <tr><td class="paramname">ap</td><td>The arguments to use to fill out the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
The extensions are:</pre></dd></dl>
<p>%pA takes a struct <a class="el" href="structin__addr.html">in_addr</a> *, and prints it as a.b.c.d %pI takes an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> * and prints it as a.b.c.d:port or</p>
<pre>%pT takes an apr_os_thread_t * and prints it in decimal
     ('0' is printed if !APR_HAS_THREADS)
%pt takes an apr_os_thread_t * and prints it in hexadecimal
     ('0' is printed if !APR_HAS_THREADS)
%pm takes an apr_status_t * and prints the appropriate error
     string (from apr_strerror) corresponding to that error code.
%pp takes a void * and outputs it in hex
%pB takes a apr_uint32_t * as bytes and outputs it's apr_strfsize
%pF same as above, but takes a apr_off_t *
%pS same as above, but takes a apr_size_t *</pre><pre>%pA, %pI, %pT, %pp are available from APR 1.0.0 onwards (and in 0.9.x).
%pt is only available from APR 1.2.0 onwards.
%pm, %pB, %pF and %pS are only available from APR 1.3.0 onwards.</pre><pre>The %p hacks are to force gcc's printf warning code to skip
over a pointer argument without complaining.  This does
mean that the ANSI-style %p (output a void * in hex format) won't
work as expected at all, but that seems to be a fair trade-off
for the increased robustness of having printf-warnings work.</pre><pre>Additionally, apr_vformatter allows for arbitrary output methods
using the apr_vformatter_buff and flush_func.</pre><pre>The apr_vformatter_buff has two elements curpos and endpos.
curpos is where apr_vformatter will write the next byte of output.
It proceeds writing output to curpos, and updating curpos, until
either the end of output is reached, or curpos == endpos (i.e. the
buffer is full).</pre><pre>If the end of output is reached, apr_vformatter returns the
number of bytes written.</pre><pre>When the buffer is full, the flush_func is called.  The flush_func
can return -1 to indicate that no further output should be attempted,
and apr_vformatter will return immediately with -1.  Otherwise
the flush_func should flush the buffer in whatever manner is
appropriate, re apr_pool_t nitialize curpos and endpos, and return 0.</pre><pre>Note that flush_func is only invoked as a result of attempting to
write another byte at curpos when curpos &gt;= endpos.  So for
example, it's possible when the output exactly matches the buffer
space available that curpos == endpos will be true when
apr_vformatter returns.</pre><pre>apr_vformatter does not call out to any other code, it is entirely
self-contained.  This allows the callers to do things which are
otherwise "unsafe".  For example, apr_psprintf uses the "scratch"
space at the unallocated end of a block, and doesn't actually
complete the allocation until apr_vformatter returns.  apr_psprintf
would be completely broken if apr_vformatter were to call anything
that used this same pool.  Similarly http_bprintf() uses the "scratch"
space at the end of its output buffer, and doesn't actually note
that the space is in use until it either has to flush the buffer
or until apr_vformatter returns.
</pre><p>Display a prompt and read in the password from stdin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prompt</td><td>The prompt to display </td></tr>
    <tr><td class="paramname">pwbuf</td><td>Buffer to store the password </td></tr>
    <tr><td class="paramname">bufsize</td><td>The length of the password buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the password entered must be truncated to fit in the provided buffer, APR_ENAMETOOLONG will be returned. Note that the bufsize paramater is passed by reference for no reason; its value will never be modified by the apr_password_get() function.</dd></dl>
<p>Create a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sock</td><td>The new socket that has been set up. </td></tr>
    <tr><td class="paramname">family</td><td>The address family of the socket (e.g., APR_INET). </td></tr>
    <tr><td class="paramname">type</td><td>The type of the socket (e.g., SOCK_STREAM). </td></tr>
    <tr><td class="paramname">protocol</td><td>The protocol of the socket (e.g., APR_PROTO_TCP). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool for the <a class="el" href="structapr__socket__t.html">apr_socket_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Shutdown either reading, writing, or both sides of a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close </td></tr>
    <tr><td class="paramname">how</td><td>How to shutdown the socket. One of: <pre>
           APR_SHUTDOWN_READ         no longer allow read requests
           APR_SHUTDOWN_WRITE        no longer allow write requests
           APR_SHUTDOWN_READWRITE    no longer allow read or write requests 
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__network__io.html#gae2130f1fa2d0db58c5c3c9c73d9b4009">apr_shutdown_how_e</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually close the socket descriptor, it just controls which calls are still valid on the socket.</dd></dl>
<p>Close a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close</td></tr>
  </table>
  </dd>
</dl>
<p>Bind the socket to its associated port </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to bind </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This may be where we will find out if there is any other process using the selected port.</dd></dl>
<p>Listen to a bound socket for connections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to listen on </td></tr>
    <tr><td class="paramname">backlog</td><td>The number of outstanding connections allowed in the sockets listen queue. If this value is less than zero, the listen queue size is set to zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Accept a new connection request </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sock</td><td>A copy of the socket that is connected to the socket that made the connection request. This is the socket which should be used for all future communication. </td></tr>
    <tr><td class="paramname">sock</td><td>The socket we are listening on. </td></tr>
    <tr><td class="paramname">connection_pool</td><td>The pool for the new socket.</td></tr>
  </table>
  </dd>
</dl>
<p>Issue a connection request to a socket either on the same machine or a different one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket we wish to use for our side of the connection </td></tr>
    <tr><td class="paramname">sa</td><td>The address of the machine we wish to connect to.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine whether the receive part of the socket has been closed by the peer (such that a subsequent call to apr_socket_read would return APR_EOF), if the socket's receive buffer is empty. This function does not block waiting for I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to check </td></tr>
    <tr><td class="paramname">atreadeof</td><td>If APR_SUCCESS is returned, *atreadeof is set to non-zero if a subsequent read would return APR_EOF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error is returned if it was not possible to determine the status, in which case *atreadeof is not changed.</dd></dl>
<p>Create <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> from hostname, address family, and port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The new <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">hostname</td><td>The hostname or numeric address string to resolve/parse, or NULL to build an address that corresponds to 0.0.0.0 or :: </td></tr>
    <tr><td class="paramname">family</td><td>The address family to use, or APR_UNSPEC if the system should decide. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags: <pre>
      APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look
                                for IPv6 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL; mutually exclusive with
                                APR_IPV6_ADDR_OK
      APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look
                                for IPv4 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL and APR_HAVE_IPV6; mutually exclusive
                                with APR_IPV4_ADDR_OK
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>The pool for the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Look up the host name from an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>The hostname. </td></tr>
    <tr><td class="paramname">sa</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags.</td></tr>
  </table>
  </dd>
</dl>
<p>Parse hostname/IP address with scope id and port.</p>
<p>Any of the following strings are accepted: 8080 (just the port number) www.apache.org (just the hostname) www.apache.org:8080 (hostname and port number)</p>
<p>[fe80::1eth0] (IPv6 numeric address string and scope id)</p>
<p>Invalid strings: (empty string) [abc] (not valid IPv6 numeric address string) abc:65536 (invalid port number)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The new buffer containing just the hostname. On output, *addr will be NULL if no hostname/IP address was specfied. </td></tr>
    <tr><td class="paramname">scope_id</td><td>The new buffer containing just the scope id. On output, *scope_id will be NULL if no scope id was specified. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. On output, *port will be 0 if no port was specified. <h3>FIXME: 0 is a legal port (per RFC 1700). this should</h3>
</td></tr>
  </table>
  </dd>
</dl>
<h3>return something besides zero if the port is missing.</h3>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string to be parsed. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which *addr and *scope_id are allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If scope id shouldn't be allowed, check for scope_id != NULL in addition to checking the return code. If addr/hostname should be required, check for addr == NULL in addition to checking the return code.</dd></dl>
<p>Get name of the current machine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to store the hostname in. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum length of the hostname that can be stored in the buffer provided. The suggested length is APRMAXHOSTLEN + 1. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the buffer was not large enough, an error will be returned.</dd></dl>
<p>Return the data associated with the current socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the user data. </td></tr>
    <tr><td class="paramname">sock</td><td>The currently open socket.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The currently open socket. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup to call when the socket is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>Send data over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to send; on exit, the number of bytes sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
socket option.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Send multiple packets of data over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">vec</td><td>The array of iovec structs containing the data to send </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of iovec structs in the array </td></tr>
    <tr><td class="paramname">len</td><td>Receives the number of bytes actually written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
socket option.
The number of bytes actually sent is stored in argument 3.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send from </td></tr>
    <tr><td class="paramname">where</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> describing where to send the data </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The data to send </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to send</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from a socket. On success, the address of the peer from which the data was sent is copied into the <em>from</em> parameter, and the <em>len</em> parameter is updated to give the number of bytes written to <em>buf</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Updated with the address from which the data was received </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to use </td></tr>
    <tr><td class="paramname">len</td><td>The length of the available buffer</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to read the data from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to receive; on exit, the number of bytes received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking read by default.  To change 
this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
socket option.
The number of bytes actually received is stored in argument 3.</pre></dd></dl>
<p>It is possible for both bytes to be received and an APR_EOF or other error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Setup socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to configure. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
                                 When this option is enabled, use
                                 the <a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#ga9dd578bfcd76a2d997395608ae5b3a4e">APR_STATUS_IS_EAGAIN()</a> macro to
                                 see if a send or receive function
                                 could not transfer data without
                                 blocking.
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Value for the option.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">t</td><td>Value for the timeout. <pre>
  t &gt; 0  &ndash; read and write calls return APR_TIMEUP if specified time
            elapsess with no data read or written
  t == 0 &ndash; read and write calls never block
  t &lt; 0  &ndash; read and write calls block
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Query socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to query. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
           APR_SO_DISCONNECTED -- Query the disconnected state of the socket.
                                 (Currently only used on Windows)
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Socket option returned on the call.</td></tr>
  </table>
  </dd>
</dl>
<p>Query socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">t</td><td>Socket timeout returned from the query.</td></tr>
  </table>
  </dd>
</dl>
<p>Query the specified socket if at the OOB/Urgent data mark </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">atmark</td><td>Is set to true if socket is at the OOB/urgent mark, otherwise is set to false.</td></tr>
  </table>
  </dd>
</dl>
<p>Return an address associated with a socket; either the address to which the socket is bound locally or the the address of the peer to which the socket is connected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The returned <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">which</td><td>Whether to retrieve the local or remote address </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the IP address (in numeric address string format) in an APR socket address. APR will allocate storage for the IP address string from the pool of the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The IP address. </td></tr>
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the IP address (in numeric address string format) of the APR socket address <em>sockaddr</em> into the buffer <em>buf</em> (of size <em>buflen</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>See if the IP addresses in two APR socket addresses are equivalent. Appropriate logic is present for comparing IPv4-mapped IPv6 addresses with IPv4 addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr1</td><td>One of the APR socket addresses. </td></tr>
    <tr><td class="paramname">addr2</td><td>The other APR socket address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return value will be non-zero if the addresses are equivalent.</dd></dl>
<p>Return the type of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">type</td><td>The returned type (e.g., SOCK_STREAM).</td></tr>
  </table>
  </dd>
</dl>
<p>Given an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and a service name, set the port for the service </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> that will have its port set </td></tr>
    <tr><td class="paramname">servname</td><td>The name of the service you wish to use</td></tr>
  </table>
  </dd>
</dl>
<p>Build an ip-subnet representation from an IP address and optional netmask or number-of-bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The new ip-subnet representation </td></tr>
    <tr><td class="paramname">ipstr</td><td>The input IP address string </td></tr>
    <tr><td class="paramname">mask_or_numbits</td><td>The input netmask or number-of-bits string, or NULL </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate from</td></tr>
  </table>
  </dd>
</dl>
<p>Test the IP address in an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> against a pre-built ip-subnet representation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The ip-subnet representation </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the socket address is within the subnet, 0 otherwise</dd></dl>
<p>Return the protocol of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">protocol</td><td>The returned protocol (e.g., APR_PROTO_TCP).</td></tr>
  </table>
  </dd>
</dl>
<p>Join a Multicast Group </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to join a multicast group </td></tr>
    <tr><td class="paramname">join</td><td>The address of the multicast group to join </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Leave a Multicast Group. All arguments must be the same as apr_mcast_join. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to leave a multicast group </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the multicast group to leave </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Multicast Time to Live (ttl) for a multicast transmission. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast ttl </td></tr>
    <tr><td class="paramname">ttl</td><td>Time to live to Assign. 0-255, default=1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the TTL is 0, packets will only be seen by sockets on the local machine, and only when multicast loopback is enabled.</dd></dl>
<p>Toggle IP Multicast Loopback </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set multicast loopback </td></tr>
    <tr><td class="paramname">opt</td><td>0=disable, 1=enable</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Interface to be used for outgoing Multicast Transmissions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast interface on </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use for Multicast</td></tr>
  </table>
  </dd>
</dl>
<p>Set up a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that this pollset can hold </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollset </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_THREADSAFE, then a pollset is created on which it is safe to make concurrent calls to apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from separate threads. This feature is only supported on some platforms; the apr_pollset_create() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_WAKEABLE, then a pollset is created with an additional internal pipe object used for the apr_pollset_wakeup() call. The actual size of pollset is in that case size + 1. This feature is only supported on some platforms; the apr_pollset_create() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_NOCOPY, then the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures passed to apr_pollset_add() are not copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Some poll methods (including APR_POLLSET_KQUEUE, APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a fixed limit on the size of the pollset. For these methods, the size parameter controls the maximum number of descriptors that will be returned by a single call to apr_pollset_poll().</dd></dl>
<p>Set up a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that this pollset can hold </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollset </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollset. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_THREADSAFE, then a pollset is created on which it is safe to make concurrent calls to apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from separate threads. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_WAKEABLE, then a pollset is created with additional internal pipe object used for the apr_pollset_wakeup() call. The actual size of pollset is in that case size + 1. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_NOCOPY, then the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures passed to apr_pollset_add() are not copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Some poll methods (including APR_POLLSET_KQUEUE, APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a fixed limit on the size of the pollset. For these methods, the size parameter controls the maximum number of descriptors that will be returned by a single call to apr_pollset_poll().</dd></dl>
<p>Destroy a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to destroy</td></tr>
  </table>
  </dd>
</dl>
<p>Add a socket or file descriptor to a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollset_poll(). </dd>
<dd>
If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_add() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically include the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
If the pollset has been created with APR_POLLSET_NOCOPY, the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structure referenced by descriptor will not be copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollset multiple times, even if the requested events differ for the different calls to apr_pollset_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollset with apr_pollset_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_remove() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically exclude the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
apr_pollset_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
    <tr><td class="paramname">num</td><td>Number of signalled descriptors (output parameter) </td></tr>
    <tr><td class="paramname">descriptors</td><td>Array of signalled descriptors (output parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>APR_EINTR will be returned if the pollset has been created with APR_POLLSET_WAKEABLE, apr_pollset_wakeup() has been called while waiting for activity, and there were no signalled descriptors at the time of the wakeup call. </dd>
<dd>
Multiple signalled conditions for the same descriptor may be reported in one or more returned <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures, depending on the implementation. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </dd></dl>
<p>Interrupt the blocked apr_pollset_poll() call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollset was not created with APR_POLLSET_WAKEABLE the return value is APR_EINIT.</dd></dl>
<p>Poll the descriptors in the poll structure </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprset</td><td>The poll structure we will be using. </td></tr>
    <tr><td class="paramname">numsock</td><td>The number of descriptors we are polling </td></tr>
    <tr><td class="paramname">nsds</td><td>The number of descriptors signalled (output parameter) </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The number of descriptors signalled is returned in the third argument. This is a blocking call, and it will not return until either a descriptor has been signalled or the timeout has expired. </dd>
<dd>
The rtnevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> array will only be filled- in if the return value is APR_SUCCESS. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Pollcb is only supported on some platforms; the apr_pollcb_create() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Pollcb is only supported on some platforms; the apr_pollcb_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Add a socket or file descriptor to a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollcb_poll(). </dd>
<dd>
Unlike the apr_pollset API, the descriptor is not copied, and users must retain the memory used by descriptor, as the same pointer will be returned to them from apr_pollcb_poll. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollcb multiple times, even if the requested events differ for the different calls to apr_pollcb_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollcb with apr_pollcb_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_pollcb_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled. </td></tr>
    <tr><td class="paramname">func</td><td>Callback function to call for each active descriptor. </td></tr>
    <tr><td class="paramname">baton</td><td>Opaque baton passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Multiple signalled conditions for the same descriptor may be reported in one or more calls to the callback function, depending on the implementation. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000005">Bug:</a></b></dt><dd>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </dd></dl>
<p>Setup all of the internal structures required to use pools </p><dl class="section remark"><dt>Remarks</dt><dd>Programs do NOT need to call this directly. APR will call this automatically from apr_initialize.</dd></dl>
<p>Create a new pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the apr_pool_t will be a sub-pool. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL the allocator of the parent pool will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread-safe, in the sense that multiple threads can safely create subpools of the same parent pool concurrently. Similarly, a subpool can be created by one thread at the same time that another thread accesses the parent pool.</dd></dl>
<p>Create a new pool. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000033">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex.</dd></dl>
<p>Create a new unmanaged pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL a new allocator will be crated with newpool as owner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unmanaged pool is a special pool without a parent; it will NOT be destroyed upon apr_terminate. It must be explicitly destroyed by calling apr_pool_destroy, to prevent memory leaks. Use of this function is discouraged, think twice about whether you really really need it.</dd></dl>
<p>Debug version of apr_pool_create_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_create_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_ex in a wrapper, trust the macro and don't call apr_pool_create_ex_debug directly.</dd></dl>
<p>Debug version of apr_pool_create_core_ex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000034">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex_debug.</dd></dl>
<p>Debug version of apr_pool_create_unmanaged_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_create_unmanaged_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_core_ex in a wrapper, trust the macro and don't call apr_pool_create_core_ex_debug directly.</dd></dl>
<p>Determine if pool a is an ancestor of pool b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to search </td></tr>
    <tr><td class="paramname">b</td><td>The pool to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a is an ancestor of b, NULL is considered an ancestor of all pools. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if compiled with APR_POOL_DEBUG, this function will also return true if A is a pool which has been guaranteed by the caller (using apr_pool_join) to have a lifetime at least as long as some ancestor of pool B.</dd></dl>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The data to be attached to the pool should have a life span at least as long as the pool it is being attached to.</dd></dl>
<p>Users of APR must take EXTREME care when choosing a key to use for their data. It is possible to accidentally overwrite data by choosing a key that another part of the program is using. Therefore it is advised that steps are taken to ensure that unique keys are used for all of the userdata objects in a particular pool (the same key in two different pools or a pool and one of its subpools is okay) at all times. Careful namespace prefixing of key names is a typical way to help ensure this uniqueness.</p>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>same as apr_pool_userdata_set(), except that this version doesn't make a copy of the key (this function is useful, for example, when the key is a string literal) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should NOT be used if the key could change addresses by any means between the apr_pool_userdata_setn() call and a subsequent apr_pool_userdata_get() on that key, such as if a static string is used as a userdata key in a DSO and the DSO could be unloaded and reloaded between the _setn() and the _get(). You MUST use apr_pool_userdata_set() in such cases. </dd>
<dd>
More generally, the key and the data to be attached to the pool should have a life span at least as long as the pool itself.</dd></dl>
<p>Return the data associated with the current pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key for the data to retrieve </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool.</td></tr>
  </table>
  </dd>
</dl>
<p>Run the specified cleanup function immediately and unregister it.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>cleanup</em> will be removed and <em>cleanup</em> will be called with <em>data</em> as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to remove the cleanup from </td></tr>
    <tr><td class="paramname">data</td><td>The data to remove from cleanup </td></tr>
    <tr><td class="paramname">cleanup</td><td>The function to remove from cleanup</td></tr>
  </table>
  </dd>
</dl>
<p>convert the file from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The os specific file we are converting to </td></tr>
    <tr><td class="paramname">file</td><td>The apr file to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to get a file descriptor from an apr file type.</dd></dl>
<p>convert the dir from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>The os specific dir we are converting to </td></tr>
    <tr><td class="paramname">dir</td><td>The apr dir to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the socket from an apr type to an OS specific socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesock</td><td>The socket to convert. </td></tr>
    <tr><td class="paramname">sock</td><td>The os specific equivalent of the apr socket..</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from os specific type to apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the exploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Get the imploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shm from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osshm</td><td>The os specific shm representation </td></tr>
    <tr><td class="paramname">shm</td><td>The apr shm to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific file to convert </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that were used to open this file. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">register_cleanup</td><td>A cleanup will be registered on the <a class="el" href="structapr__file__t.html">apr_file_t</a> to issue apr_file_close(). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the dir from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The apr dir we are converting to. </td></tr>
    <tr><td class="paramname">thedir</td><td>The os specific dir to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use when creating to apr directory.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a socket from the os specific type to the apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The pool to use. </td></tr>
    <tr><td class="paramname">thesock</td><td>The socket to convert to. </td></tr>
    <tr><td class="paramname">cont</td><td>The socket we are converting to an apr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If it is a true socket, it is best to call apr_os_sock_make() and provide APR with more information about the socket.</dd></dl>
<p>Create a socket from an existing descriptor and local and remote socket addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apr_sock</td><td>The new socket that has been set up </td></tr>
    <tr><td class="paramname">os_sock_info</td><td>The os representation of the socket handle and other characteristics of the socket </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you only know the descriptor/handle or if it isn't really a true socket, use apr_os_sock_put() instead.</dd></dl>
<p>Convert the proc mutex from os specific type to apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex to convert. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>Put the imploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>Put the exploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shared memory from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm</td><td>The apr shm representation of osshm </td></tr>
    <tr><td class="paramname">osshm</td><td>The os specific shm identity </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On fork()ed architectures, this is typically nothing more than the memory block mapped. On non-fork architectures, this is typically some internal handle to pass the mapping from process to process.</dd></dl>
<p>Create and initialize a mutex that can be used to synchronize processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the memory address where the newly created mutex will be stored. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the lock mechanism requires one. This argument should always be provided. The lock code itself will determine if it should be used. </td></tr>
    <tr><td class="paramname">mech</td><td>The mechanism to use for the interprocess lock, if any; one of <pre>
           APR_LOCK_FCNTL
           APR_LOCK_FLOCK
           APR_LOCK_SYSVSEM
           APR_LOCK_POSIXSEM
           APR_LOCK_PROC_PTHREAD
           APR_LOCK_DEFAULT     pick the default mechanism for the platform
</pre> </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__proc__mutex.html#ga75dd95a48a1e855a87b509b522746ed4">apr_lockmech_e</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Check APR_HAS_foo_SERIALIZE defines to see if the platform supports APR_LOCK_foo. Only APR_LOCK_DEFAULT is portable.</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_proc_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is generally used to kill a cleanup on an already created mutex</dd></dl>
<p>Generate cryptographically insecure random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state </td></tr>
    <tr><td class="paramname">random</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Generate cryptographically secure random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state </td></tr>
    <tr><td class="paramname">random</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the cryptographic PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The RNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The PRNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Create and make accessable a shared memory segment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">reqsize</td><td>The desired size of the segment. </td></tr>
    <tr><td class="paramname">filename</td><td>The file to use for shared memory on platforms that require it. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A note about Anonymous vs. Named shared memory segments: Not all plaforms support anonymous shared memory segments, but in some cases it is prefered over other types of shared memory implementations. Passing a NULL 'file' parameter to this function will cause the subsystem to use anonymous shared memory segments. If such a system is not available, APR_ENOTIMPL is returned. </dd>
<dd>
A note about allocation sizes: On some platforms it is necessary to store some metainformation about the segment within the actual segment. In order to supply the caller with the requested size it may be necessary for the implementation to request a slightly greater segment length from the subsystem. In all cases, the apr_shm_baseaddr_get() function will return the first usable byte of memory.</dd></dl>
<p>Remove named resource associated with a shared memory segment, preventing attachments to the resource, but not destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename associated with shared-memory segment which needs to be removed </td></tr>
    <tr><td class="paramname">pool</td><td>The pool used for file operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is only supported on platforms which support name-based shared memory segments, and will return APR_ENOTIMPL on platforms without such support. Removing the file while the shm is in use is not entirely portable, caller may use this to enhance obscurity of the resource, but be prepared for the the call to fail, and for concurrent attempts to create a resource of the same name to also fail. The pool cleanup of apr_shm_create (apr_shm_destroy) also removes the named resource.</dd></dl>
<p>Destroy a shared memory segment and associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory segment structure to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Attach to a shared memory segment that was created by another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">filename</td><td>The file used to create the original segment. (This MUST match the original filename.) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure for this process.</td></tr>
  </table>
  </dd>
</dl>
<p>Detach from a shared memory segment without destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure representing the segment to detach from.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a new procattr variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_attr</td><td>The newly created procattr. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if any of stdin, stdout, or stderr should be linked to pipes when starting a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">in</td><td>Should stdin be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">out</td><td>Should stdout be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">err</td><td>Should stderr be a pipe back to the parent? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If APR_NO_PIPE, there will be no special channel, the child inherits the parent's corresponding stdio stream. If APR_NO_FILE is specified, that corresponding stream is closed in the child (and will be INVALID_HANDLE_VALUE when inspected on Win32). This can have ugly side effects, as the next file opened in the child on Unix will fall into the stdio stream fd slot!</dd></dl>
<p>Set the child_in and/or parent_in values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_in. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_in. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. You can save some extra function calls by not creating your own pipe since this creates one in the process space for you. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_out and parent_out values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_out. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_out. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_err and parent_err values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_err. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_err. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set which directory the child process should start executing in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">dir</td><td>Which dir to start in. By default, this is the same dir as the parent currently resides in, when the createprocess call is made.</td></tr>
  </table>
  </dd>
</dl>
<p>Set what type of command the child process will call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">cmd</td><td>The type of command. One of: <pre>
           APR_SHELLCMD     &ndash;  Anything that the shell can handle
           APR_PROGRAM      &ndash;  Executable program   (default) 
           APR_PROGRAM_ENV  &ndash;  Executable program, copy environment
           APR_PROGRAM_PATH &ndash;  Executable program on PATH, copy env
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Determine if the child should start in detached state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">detach</td><td>Should the child start in detached state? Default is no.</td></tr>
  </table>
  </dd>
</dl>
<p>Specify an error function to be called in the child process if APR encounters an error in the child prior to running the specified program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">errfn</td><td>The function to call in the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>At the present time, it will only be called from apr_proc_create() on platforms where fork() is used. It will never be called on other platforms, on those platforms apr_proc_create() will return the error in the parent process rather than invoke the callback in the now-forked child process.</dd></dl>
<p>Specify that apr_proc_create() should do whatever it can to report failures to the caller of apr_proc_create(), rather than find out in the child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">chk</td><td>Flag to indicate whether or not extra work should be done to try to report failures to the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This flag only affects apr_proc_create() on platforms where fork() is used. This leads to extra overhead in the calling process, but that may help the application handle such errors more gracefully.</dd></dl>
<p>Determine if the child should start in its own address space or using the current one from its parent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">addrspace</td><td>Should the child start in its own address space? Default is no on NetWare and yes on other platforms.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the username used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">username</td><td>The username used </td></tr>
    <tr><td class="paramname">password</td><td>User password if needed. Password is needed on WIN32 or any other platform having APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the group used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">groupname</td><td>The group name used</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new process and execute a new program within that process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_proc</td><td>The resulting process handle. </td></tr>
    <tr><td class="paramname">progname</td><td>The program to run </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to the new program. The first one should be the program name. </td></tr>
    <tr><td class="paramname">env</td><td>The new environment table for the new process. This should be a list of NULL-terminated strings. This argument is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and APR_SHELLCMD_ENV types of commands. </td></tr>
    <tr><td class="paramname">attr</td><td>the procattr we should use to determine how to create the new process </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function returns without waiting for the new process to terminate; use apr_proc_wait for that.</dd></dl>
<p>Wait for a child process to die </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process handle that corresponds to the desired child process </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The childs status is in the return code to this process. It is one of: <pre>
           APR_CHILD_DONE     &ndash; child is no longer running.
           APR_CHILD_NOTDONE  &ndash; child is still running.
</pre></dd></dl>
<p>Wait for any current child process to die and return information about that child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Pointer to NULL on entry, will be filled out with child's information </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>Pool to allocate child information out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000010">Bug:</a></b></dt><dd>Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0 </dd></dl>
<p>Detach the process from the controlling terminal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">daemonize</td><td>set to non-zero if the process should daemonize and become a background process, else it will stay in the foreground.</td></tr>
  </table>
  </dd>
</dl>
<p>Notify the maintenance callback of a registered other child process that application has detected an event, such as death. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to check </td></tr>
    <tr><td class="paramname">reason</td><td>The reason code to pass to the maintenance function </td></tr>
    <tr><td class="paramname">status</td><td>The status to pass to the maintenance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An example of code using this behavior; <pre>
rv = apr_proc_wait_all_procs(&amp;proc, &amp;exitcode, &amp;status, APR_WAIT, p);
if (<a class="el" href="group___a_p_r___s_t_a_t_u_s___i_s.html#ga1e6539dfa172cef4026105ca33b2b208">APR_STATUS_IS_CHILD_DONE(rv)</a>) {
#if APR_HAS_OTHER_CHILD
    if (apr_proc_other_child_alert(&amp;proc, APR_OC_REASON_DEATH, status)
            == APR_SUCCESS) {
        ;  (already handled)
    }
    else
#endif
        [... handling non-otherchild processes death ...]
</pre></dd></dl>
<p>Terminate a process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to terminate. </td></tr>
    <tr><td class="paramname">sig</td><td>How to kill the process.</td></tr>
  </table>
  </dd>
</dl>
<p>convert an ansi time_t to an apr_time_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting apr_time_t </td></tr>
    <tr><td class="paramname">input</td><td>the time_t to convert</td></tr>
  </table>
  </dd>
</dl>
<p>convert a time to its human readable components using an offset from GMT </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode </td></tr>
    <tr><td class="paramname">offs</td><td>the number of seconds offset to apply</td></tr>
  </table>
  </dd>
</dl>
<p>convert a time to its human readable components in GMT timezone </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>convert a time to its human readable components in local timezone </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t e.g. elapsed usec since epoch </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t that always represents GMT </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>apr_rfc822_date formats dates in the RFC822 format in an efficient manner. It is a fixed length format which requires the indicated amount of storage, including the trailing NUL terminator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>apr_ctime formats dates in the ctime() format in an efficient manner. it is a fixed length format and requires the indicated amount of storage including the trailing NUL terminator. Unlike ANSI/ISO C ctime(), apr_ctime() does not include a <br />
 at the end of the string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>formats the exploded time according to the format specified </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to write to </td></tr>
    <tr><td class="paramname">retsize</td><td>The length of the returned string </td></tr>
    <tr><td class="paramname">max</td><td>The maximum length of the string </td></tr>
    <tr><td class="paramname">format</td><td>The format for the time string </td></tr>
    <tr><td class="paramname">tm</td><td>The time to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb34a3c199088334b7cf35f075272878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb34a3c199088334b7cf35f075272878">&#9670;&nbsp;</a></span>APR_DECLARE() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy an allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Any memnodes not given back to the allocator prior to destroying will <em>not</em> be free()d.</dd></dl>
<p>Free a list of blocks of mem, giving them back to the allocator. The list is typically terminated by a memnode with its next field set to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to give the mem back to </td></tr>
    <tr><td class="paramname">memnode</td><td>The memory node to return</td></tr>
  </table>
  </dd>
</dl>
<p>Set the owner of the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the owner for </td></tr>
    <tr><td class="paramname">pool</td><td>The pool that is to own the allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Typically pool is the highest level pool using the allocator</dd></dl>
<p>Set the current threshold at which the allocator should start giving blocks back to the system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator the set the threshold on </td></tr>
    <tr><td class="paramname">size</td><td>The threshold. 0 == unlimited.</td></tr>
  </table>
  </dd>
</dl>
<p>atomically subtract 'val' from an apr_uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the object </td></tr>
    <tr><td class="paramname">val</td><td>amount to subtract</td></tr>
  </table>
  </dd>
</dl>
<p>Get the current entry's details from the iteration state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi</td><td>The iteration state </td></tr>
    <tr><td class="paramname">key</td><td>Return pointer for the pointer to the key. </td></tr>
    <tr><td class="paramname">klen</td><td>Return pointer for the key length. </td></tr>
    <tr><td class="paramname">val</td><td>Return pointer for the associated value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return pointers should point to a variable that will be set to the corresponding data, or they may be NULL if the data isn't interesting.</dd></dl>
<p>Clear any key/value pairs in the hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table</td></tr>
  </table>
  </dd>
</dl>
<p>Clear all memory in the pool and run all the cleanups. This also destroys all subpools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually free the memory, it just allows the pool to re-use this memory for the next allocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_destroy()</dd></dl>
<p>Debug version of apr_pool_clear. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pool_clear. </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_clear calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_clear in a wrapper, trust the macro and don't call apr_pool_destroy_clear directly.</dd></dl>
<p>Destroy the pool. This takes similar action as apr_pool_clear() and then frees all the memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This will actually free the memory</dd></dl>
<p>Debug version of apr_pool_destroy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pool_destroy. </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have you apr_pool_destroy calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_destroy in a wrapper, trust the macro and don't call apr_pool_destroy_debug directly.</dd></dl>
<p>Set the function to be called when an allocation failure occurs. </p><dl class="section remark"><dt>Remarks</dt><dd>If the program wants APR to exit on a memory allocation error, then this function can be called to set the callback to use (for performing cleanup and then exiting). If this function is not called, then APR will return an error and expect the calling program to deal with the error accordingly.</dd></dl>
<p>Tag a pool (give it a name) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool to tag </td></tr>
    <tr><td class="paramname">tag</td><td>The tag</td></tr>
  </table>
  </dd>
</dl>
<p>Register a function to be called when a pool is cleared or destroyed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool register the cleanup with </td></tr>
    <tr><td class="paramname">data</td><td>The data to pass to the cleanup function. </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The function to call when the pool is cleared or destroyed </td></tr>
    <tr><td class="paramname">child_cleanup</td><td>The function to call when a child process is about to exec - this function is called in the child, obviously!</td></tr>
  </table>
  </dd>
</dl>
<p>Register a function to be called when a pool is cleared or destroyed.</p>
<p>Unlike apr_pool_cleanup_register which register a cleanup that is called AFTER all subpools are destroyed this function register a function that will be called before any of the subpool is destoryed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool register the cleanup with </td></tr>
    <tr><td class="paramname">data</td><td>The data to pass to the cleanup function. </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The function to call when the pool is cleared or destroyed</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a previously registered cleanup function.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>cleanup</em> will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to remove the cleanup from </td></tr>
    <tr><td class="paramname">data</td><td>The data of the registered cleanup </td></tr>
    <tr><td class="paramname">cleanup</td><td>The function to remove from cleanup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For some strange reason only the plain_cleanup is handled by this function</dd></dl>
<p>Replace the child cleanup function of a previously registered cleanup.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>plain_cleanup</em> will have the registered child cleanup function replaced with <em>child_cleanup</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool of the registered cleanup </td></tr>
    <tr><td class="paramname">data</td><td>The data of the registered cleanup </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The plain cleanup function of the registered cleanup </td></tr>
    <tr><td class="paramname">child_cleanup</td><td>The function to register as the child cleanup</td></tr>
  </table>
  </dd>
</dl>
<p>Run all registered child cleanups, in preparation for an exec() call in a forked child &ndash; close files, etc., but <em>don't</em> flush I/O buffers, <em>don't</em> wait for subprocesses, and <em>don't</em> free any memory.</p>
<p>Mix the randomness pools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The PRNG state </td></tr>
    <tr><td class="paramname">entropy_</td><td>Entropy buffer </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of entropy_ in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Ensures that E bits of conditional entropy are mixed into the PRNG before any further randomness is extracted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Mix the randomness pools after forking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The resulting process handle from apr_proc_fork() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Call this in the child after forking to mix the randomness pools. Note that its generally a bad idea to fork a process with a real PRNG in it - better to have the PRNG externally and get the randomness from there. However, if you really must do it, then you should supply all your entropy to all the PRNGs - don't worry, they won't produce the same output. </dd>
<dd>
Note that apr_proc_fork() calls this for you, so only weird applications need ever call it themselves.</dd></dl>
<p>Concatenate two arrays together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination array, and the one to go first in the combined array </td></tr>
    <tr><td class="paramname">src</td><td>The source array to add to the destination array</td></tr>
  </table>
  </dd>
</dl>
<p>Delete all of the elements from a table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to clear</td></tr>
  </table>
  </dd>
</dl>
<p>Add a key/value pair to a table. If another element already exists with the same key, this will overwrite the old data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function makes a copy of both the key and the value.</dd></dl>
<p>Add a key/value pair to a table. If another element already exists with the same key, this will overwrite the old data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added..</dd></dl>
<p>Remove data from the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to remove data from </td></tr>
    <tr><td class="paramname">key</td><td>The key of the data being removed (case does not matter)</td></tr>
  </table>
  </dd>
</dl>
<p>Add data to a table by merging the value with data that has already been stored. The merging is done by concatenating the two values, separated by the string ", ". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the data </td></tr>
    <tr><td class="paramname">key</td><td>The key to merge data for (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the key is not found, then this function acts like apr_table_add</dd></dl>
<p>Add data to a table by merging the value with data that has already been stored. The merging is done by concatenating the two values, separated by the string ", ". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the data </td></tr>
    <tr><td class="paramname">key</td><td>The key to merge data for (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the key is not found, then this function acts like apr_table_addn</dd></dl>
<p>Add data to a table, regardless of whether there is another element with the same key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add to </td></tr>
    <tr><td class="paramname">key</td><td>The key to use </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function makes a copy of both the key and the value.</dd></dl>
<p>Add data to a table, regardless of whether there is another element with the same key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add to </td></tr>
    <tr><td class="paramname">key</td><td>The key to use </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added.</dd></dl>
<p>For each element in table b, either use setn or mergen to add the data to table a. Which method is used is determined by the flags passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">b</td><td>The table to iterate over, adding its data to table a </td></tr>
    <tr><td class="paramname">flags</td><td>How to add the table to table a. One of: APR_OVERLAP_TABLES_SET Use apr_table_setn APR_OVERLAP_TABLES_MERGE Use apr_table_mergen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When merging duplicates, the two values are concatenated, separated by the string ", ". </dd>
<dd>
This function is highly optimized, and uses less memory and CPU cycles than a function that just loops through table b calling other functions. Conceptually, apr_table_overlap does this:</dd></dl>
<pre>
 <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *barr = apr_table_elts(b);
 <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *belt = (<a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *)barr-&gt;elts;
 int i;</pre><pre> for (i = 0; i &lt; barr-&gt;nelts; ++i) {
     if (flags &amp; APR_OVERLAP_TABLES_MERGE) {
         apr_table_mergen(a, belt[i].key, belt[i].val);
     }
     else {
         apr_table_setn(a, belt[i].key, belt[i].val);
     }
 }
</pre><p>Except that it is more efficient (less space and cpu-time) especially when b has many elements.</p>
<p>Notice the assumptions on the keys and values in b &ndash; they must be in an ancestor of a's pool. In practice b and a are usually from the same pool.</p>
<p>Eliminate redundant entries in a table by either overwriting or merging duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table. </td></tr>
    <tr><td class="paramname">flags</td><td>APR_OVERLAP_TABLES_MERGE to merge, or APR_OVERLAP_TABLES_SET to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When merging duplicates, the two values are concatenated, separated by the string ", ".</dd></dl>
<p>Stop watching the specified other child. <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to pass to the maintenance function. This is used to find the process to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Since this can be called by a maintenance function while we're scanning the other_children list, all scanners should protect themself by loading ocr-&gt;next before calling any maintenance function.</dd></dl>
<p>Test one specific other child processes and invoke the maintenance callback with the appropriate reason code, if still running, or the appropriate reason code if the process is no longer healthy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ocr</td><td>The registered other child </td></tr>
    <tr><td class="paramname">reason</td><td>The reason code (e.g. APR_OC_REASON_RESTART) if still running</td></tr>
  </table>
  </dd>
</dl>
<p>Test all registered other child processes and invoke the maintenance callback with the appropriate reason code, if still running, or the appropriate reason code if the process is no longer healthy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason code (e.g. APR_OC_REASON_RESTART) to running processes</td></tr>
  </table>
  </dd>
</dl>
<p>Register a process to be killed when a pool dies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to use to define the processes lifetime </td></tr>
    <tr><td class="paramname">proc</td><td>The process to register </td></tr>
    <tr><td class="paramname">how</td><td>How to kill the process, one of: <pre>
        APR_KILL_NEVER         &ndash; process is never sent any signals
        APR_KILL_ALWAYS        &ndash; process is sent SIGKILL on apr_pool_t cleanup
        APR_KILL_AFTER_TIMEOUT &ndash; SIGTERM, wait 3 seconds, SIGKILL
        APR_JUST_WAIT          &ndash; wait forever for the process to complete
        APR_KILL_ONLY_ONCE     &ndash; send SIGTERM and then wait
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Improve the clock resolution for the lifetime of the given pool. Generally this is only desireable on benchmarking and other very time-sensitive applications, and has no impact on most platforms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to associate the finer clock resolution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a358d9857909db42118ab336d2ed241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a358d9857909db42118ab336d2ed241">&#9670;&nbsp;</a></span>APR_DECLARE() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a block of mem from the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to allocate from </td></tr>
    <tr><td class="paramname">size</td><td>The size of the mem to allocate (excluding the memnode structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabccd1c0312bb5004cdca788c3a3422f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabccd1c0312bb5004cdca788c3a3422f9">&#9670;&nbsp;</a></span>APR_DECLARE() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current owner of the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to get the owner from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
