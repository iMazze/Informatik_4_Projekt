<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Complex Calculator: Bug List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Complex Calculator
   </div>
   <div id="projectbrief">DHBW Friedrichshafen: Informatik 4</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Bug List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000011"></a>Member <a class="el" href="group__apr__time.html#ga82e8a0064bc8dd25ef73f39ea428a585">APR_DECLARE</a>  (void) apr_sleep(apr_interval_time_t t)</dt>
<dd><p class="startdd">write_fd duplicates the proc-&gt;out stream, it's really redundant and should be replaced in the APR 1.0 API with a bitflag of which proc-&gt;in/out/err handles should be health checked. </p>
<p class="enddd">no platform currently tests the pipes health.  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000011"></a>Member <a class="el" href="group__apr__time.html#ga82e8a0064bc8dd25ef73f39ea428a585">APR_DECLARE</a>  (void) apr_sleep(apr_interval_time_t t)</dt>
<dd><p class="startdd">write_fd duplicates the proc-&gt;out stream, it's really redundant and should be replaced in the APR 1.0 API with a bitflag of which proc-&gt;in/out/err handles should be health checked. </p>
<p class="enddd">no platform currently tests the pipes health.  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000011"></a>Member <a class="el" href="group__apr__time.html#ga82e8a0064bc8dd25ef73f39ea428a585">APR_DECLARE</a>  (void) apr_sleep(apr_interval_time_t t)</dt>
<dd><p class="startdd">write_fd duplicates the proc-&gt;out stream, it's really redundant and should be replaced in the APR 1.0 API with a bitflag of which proc-&gt;in/out/err handles should be health checked. </p>
<p class="enddd">no platform currently tests the pipes health.  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000002"></a>Member <a class="el" href="group__apr__time.html#ga57bfe39a9516843a151a65cd02f84616">APR_DECLARE</a>  (apr_status_t) apr_time_ansi_put(apr_time_t *result</dt>
<dd><p class="startdd">Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>With versions 1.4.2 and prior on Windows, a call with no descriptors and timeout will return immediately with the wrong error code. </p>
<p>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</p>
<p class="enddd">Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </p>
</dd>
<dt><a class="anchor" id="_bug000001"></a>Member <a class="el" href="group__apr__filepath.html#gabb57ce7b23caf512d7f64b92a662ab3d">APR_FILEPATH_NOTABOVEROOT</a>  </dt>
<dd>in APR 0.9 and 1.x, this flag's behavior is undefined if the rootpath is NULL or empty. In APR 2.0 this should be changed to imply NOTABSOLUTE if the rootpath is NULL or empty. </dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
